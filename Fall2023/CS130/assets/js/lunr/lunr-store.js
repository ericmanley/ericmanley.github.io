var store = [{
        "title": "Lecture: Computer Organization",
        "excerpt":"# Computer Organization #### and Assembly Language Programming  ---  CS 130 // 2023-08-29    # Welcome! Instructor: Eric Manley  ---     **Office:** Collier-Scripps 327 **Email:**  **Phone:** (515) 271-2177     **Office Hours:** Schedule in StarFish the day before or drop inM 10:00am-1:00pmT 10:00am-12:00pm (tentative)         # Course Overview     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    So... what is a processor?     ![Photo of the inside of a laptop](/Fall2023/CS130/assets/images/COD/inside-laptop.png)    ![Components of a processor](/Fall2023/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2023/CS130/assets/images/COD/control.png)    ![Compiler-Assembler Diagram](/Fall2023/CS130/assets/images/COD/compiler-assembler.png)     ## Major Aspects of the Course 1. Assembly language programming 2.   Digital logic 3.   Processor architecture 4.  The C Programming Language     #### Why should I learn this stuff?    Sometimes you really need to understand the system to solve your problems  ![Shazam movie poster](/Fall2023/CS130/assets/images/shazam-movie.jpg)    Wait, that's the wrong Shazam      #### Shazam - the transaction processing company  ![Transaction processing network](/Fall2023/CS130/assets/images/transaction-processing-network.png) - They hire developers in Des Moines - Need to process transactions fast  - If the Java garbage collector kicks in, they're in trouble    #### How does magic *really* work in our world?        ![Door to Moria](/Fall2023/CS130/assets/images/moria-door.webp)   ![Mistborn novel cover](/Fall2023/CS130/assets/images/mistborn-book.jpg)      ![Dungeons and Dragons spells](/Fall2023/CS130/assets/images/phb-spells.jpg)             ### My background with this course  - 1996-2004: C/C++ was my _native_ language -   2001: I took a course in _assembly_ and _digital circuits_     - didn't understand how it related to actual computers -   2003: Took an awful course on computer architecture     - deathly afraid of systems courses -   2005: ðŸ˜± assigned to teach _computer organization and assembly language programming_ in grad school     - ended up teaching it 8 semesters in a row    - 2007: ðŸ˜± took a qualifying exam on computer architecture     - read the entire textbook _and_ the sequel -   2009: got Ph.D.      - this stuff was an important part of my research     ![optical scalar multiplication](/Fall2023/CS130/assets/images/optical-scalar-mult.png) -   2022-2023: Teaching this course after 13 year break    # Course Logistics     ## Course Website   [https://ericmanley.github.io/Fall2023/CS130](https://ericmanley.github.io/Fall2023/CS130/)     #### What to do before coming to the next class    1. Read the [syllabus](https://ericmanley.github.io/Fall2023/CS130/syllabus) 2. From the [resources](https://ericmanley.github.io/Fall2023/CS130/resources) page  - If you don't have a JAVA SDK installed, install a Java SDK     - CS67 students - try the one your instructor wants first  - Download and run MARS - the MIPS simulator we'll be using     ## Warm up exercises  Get in groups discuss and write down your ideas  1. Rewrite the following code with one arithmetic operator (+, -, etc.) per line ```python pay = (salary + bonus) - (health_premium + taxes) ```  2. Rewrite lines of this form ```python a = b + c ``` like this ``` add a, b, c ```    ## Discussion Questions  1. What is the difference between computer _memory_ and the computer _disk_? 2. When using Excel spreadsheets, what causes something to be in memory? What causes something to be on the disk? 3. When writing a Python program, what causes something to be in memory? What causes something to be on the disk?    ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-08-29-introduction-to-computer-organization/",
        "teaser": null
      },{
        "title": "Mips Assembly Language",
        "excerpt":"## Introduction to # MIPS ---   CS 130 // 2023-08-31    # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2023/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. **Assembly language programming** 2. Digital logic 3. Processor architecture 4. The C Programming Language    # Assembly Languages     ## Assembly Languages - Every CPU architecture implements an **instruction set** which are the operations it natively supports -   The most common CPU architectures are:     + x86 (Intel/AMD)     +   ARM (Mobile phones, tablets, Apple's M1 chip, ...)  -   Instructions are extremely simple like ``` add a, b, c ```    ## Revisiting the Exercise from last time  A complicated line of high-level code like this ```python pay = (salary + bonus) - (health_premium + taxes) ```  Gets translated by the *compiler* into assembly code like ```bash add basepay, salary, bonus add deductions, health_premium, taxes sub pay, basepay, deductions ```      ## RISC vs. CISC - CPU architectures are usually categorized as either \"RISC\" or \"CISC\" -   RISC (Reduced Instruction Set Computing)     + Simplified instructions which \"do less\"     + ...but each instruction is highly optimized    ## RISC vs. CISC - CISC (Complicated Instruction Set Computing)     + Larger instruction set each of which \"does more\"     + Optimized so that a program can be implemented with few instructions---even though those instructions may take longer to execute    # MIPS     ## MIPS Architecture - In this course, we will be learning the MIPS instruction set     + \"Microprocessor without Interlocked Pipelined Stages\" - MIPS is a RISC processor with a minimalistic number of instructions - Is very similar to ARM     ## Discussion Question    - what exactly are `salary` or `taxes`  in this example?    ```python pay = (salary + bonus) - (health_premium + taxes) ```     ## Pointers  - In assembly programs, labels like `salary` or `taxes` are *pointers*  -   **pointer**: a stand-in for a _memory address_  -   Even this is too complicated for RISC ```bash add basepay, salary, bonus ```  -   You might first have to grab the data at the address indicated by the pointer _before_ you can do any operations on it.    ## Grabbing data from memory  - When we grab data from memory, where do we put it?  -   **Registers**: a holding place for data right inside the CPU   - data has to be in a register before you can perform operations    ![Processor component diagram](/Fall2023/CS130/assets/images/COD/control.png)    ## MIPS Architecture - Has 32 registers, each of which are 32-bits -   Why not include more registers?     +   Cost; registers are more expensive than RAM     +   Performance; more registers means slower clock     +   Instruction size; more registers means each instruction needs more bits to identify registers     #### A MIPS program in MARS  ![Processor component diagram](/Fall2023/CS130/assets/images/first_program.png)     #### Things to notice in MARS  - Registers have names like `$t0`, `$s2`, etc. - You can refer to a register by its name or number.    - `$t0` is also `$8` - MARS can be wonky   - MARS didn't play nice with OneDrive for me - you may need to create a folder for your `.asm` files in your home directory - `lw` means _load word_   - a **word** is a 32 bit value  ```mips #loads a value from memory location a into register $t0 lw $t0, a   ```        #### Exploration Exercise  1. Write the above program in MARS 2. What values are stored in each of the registers initially? 3. Find and press the **Assemble** button 4. What memory addresses did your *program* get stored in? 5. What memory addresses did your *data* get stored in? 6. Find and press the **Run** button 7. What values ended up in `$t0`, `$t1`, and `$t2`? Is that what you expected?    8. Change `a`'s initial value to 9 and rerun. What is in `$t2` now? What do you think is going on here? 9. Add the following to your data section ```mips result: 0 ``` 10. Add the following to the end of your text section ```mips sw $t2, result ``` 11. Rerun. Look in memory - is there a new value there? 12. What do you think `sw` means? 13. Try the **Run one step at a time** button and step through the program slowly. Watch the values change in the registers.     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-08-31-mips-assembly-language/",
        "teaser": null
      },{
        "title": "Registers Instructions System Calls",
        "excerpt":"# Registers, Instructions, and System Calls  ---    CS 130 // 2023-09-05    # Review      ## Recap of last week  - MIPS: RISC architecture   + 32, 32-bit registers - We wrote some a simple MIPS program in Mars   + watched data change in registers and memory - Data and instructions get turned into binary and placed in memory     - Covered `add`, `lw`, `sw`  ```mips .data  a: 9 b: 3 result: 0   .text  lw $t0, a lw $t1, b add $t2, $t0, $t1 sw $t2, result ```    # More on Registers and Instructions      ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Assignment: Interactive Program  You now know enough to do the first assignment  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook       # Binary Numbers     ## Let's talk about how counting works  ![Odometer rollover](/Fall2023/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits? ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-05-registers-instructions-system-calls/",
        "teaser": null
      },{
        "title": "Numbers And Machine Code",
        "excerpt":"# Numbers and Machine Code  ---    CS 130 // 2023-09-07         ## Student Research Groups  Friday, September 8th at 1:00pm in C-S 301  No experience required  Come to learn more about possible research groups in mathematics, computer science, math education, data science, cyber security, and more!    # CS Jokes  ![Only 10 types of people shirt](/Fall2023/CS130/assets/images/shirt10typesOfPeople.jpg)   Source: https://www.amazon.com/Types-People-understand-Binary-T-Shirt/dp/B07PSPLSC9    # Binary Numbers     ## Let's talk about how counting works  ![Odometer rollover](/Fall2023/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits?     ## Counting in Binary - CPUs compute in **binary** using the contrast of low/high voltages to mean 0 and 1 - the two _binary digits_ or **bits** - So how do we encode **numbers** in binary?     ## Base 10 (AKA Decimal)  - When we write 437 we usually mean base 10 - the number system with 10 digits  - Can also write it as $437_\\text{ten}$   - $437_\\text{ten}$ means   `$$(4\\cdot 100)+(3\\cdot 10)+(7\\cdot 1)$$`  or  `$$(4\\cdot 10^2)+(3\\cdot 10^1)+(7\\cdot 10^0)$$`    ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`     ### Demo: Let's convert numbers to different bases   - $110110101_\\text{two}$  - $437_\\text{ten}$    ### Exercise: Practice with Binary - Convert the following number into decimal:     + $1011010_\\text{two}$ - Convert the following decimal number into binary:     + $277_\\text{ten}$      ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0 0      1 1 1       2 102      3 11 3      4 1004      5 1015      6 1106      7 1117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 1000010      17 1000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$    # Negative Numbers     ## Negative Numbers in Binary - We usually represent negative numbers by including a \"minus sign\" at the beginning of a number: $-437$ -   However, when representing numbers for logic circuits, we can **ONLY** use $0$s and $1$s. -   So what do we do?    ## Idea 1: Using a Sign Bit - We could treat the first bit of a number as the \"sign\" bit where $0$ means positive and $1$ means negative     + $10010$ is the same as $-0010$     + $01010$ is the same as $+1010$ -   Drawbacks     + Multiple representations for $0$     +   Addition/subtraction is not as convenient     +   Confusion over where the sign bit should be      ## Idea 2: Wrap Around  ![Odometer rollover](/Fall2023/CS130/assets/images/Odometer_rollover.jpg)   - Numbers \"wrap around\" from the **largest** number $999999$ to the **smallest** $000000$ -   We can do the same thing in binary!     +   If you add one to the largest number, it \"wraps around\" to the smallest negative number          # Two's Complement     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$        ## Two's Complement - Most processors are 32-bit or 64-bit, which means values sent to the processor are encoded in 32 or 64 bits, respectively -   In this class, we are using the MIPS 32-bit architecture -   Another way to think about two's complement is:      $1000\\\\;1001\\\\;1100\\\\;1010\\\\;0110\\\\;0110\\\\;0001\\\\;1110$      $(x_{31}\\cdot -2^{31}) + (x_{30}\\cdot 2^{30}) + \\cdots + (x_{1}\\cdot 2^{1}) + (x_{0}\\cdot 2^{0})$    ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$     ## Assignment is up  - [Assignment 2](../../assignments/assignment-2/)   - pen-and-paper    - convert some numbers between decimal, hexadecimal, and binary    # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2023/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2023/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2023/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## R-Type VS I-Type - Which type are each of the following instructions?     +   add     +   addi     +   sub     +   lw     +   sw    ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$   ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-07-numbers-and-machine-code/",
        "teaser": null
      },{
        "title": "Machine Code Logic Operations And Conditionals",
        "excerpt":"# Machine Code and Logic Operations  ---  CS 130 // 2023-09-12    ## Office Hours Change  Office hours changing to   Mondays 10:00am-1:00pm (new time)  Tuesdays 10:00am-noon (same as before)  Wednesdays: None   **Except:** I will not have office hours September 18th - I will try to add some additional times next week and post it to StarFish    # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2023/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2023/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2023/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## Exercise  - Use Mars to figure out how each of the following is represented in bits (convert from hex!). ```mips add $t2, $t1, $t0 sub $t2, $t1, $t0 addi $t0, $t0, 3 ``` - What are the opcodes for `add`, `sub`, and `addi`?     ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$     # Logical Operations     ## Boolean values - Suppose I create a `bool` variable in Python:     ```py     b = True     ``` -   How many bits of memory were just allocated?     +   An entire word!     +   `b` is a **memory address** that \"points to\" `True`    ## Logical operator investigation     Before executing: guess what you think `$t0`-`$t5` will be   Execute it: were you right?  Is this how `and` and `or` behave in Python?    ```mips    .text     li $s0, 0    li $s1, 1    li $s2, 2    li $s3, 3        and $t0, $s0, $s1    or $t1, $s0, $s1    andi $t2, $s1, 1    ori $t3, $s1, 0        or $t4, $s1, $s2    and $t5, $s2, $s3 ```       ## Set on Less Than investigation     Before executing: guess what you think `$t0`-`$t5` will be  Execute it: were you right?  What do `sle` and `sgt` mean? What do they get translated into by the assemler?    ```mips .text   li $s1, 2 li $s2, 2 li $s3, 3  #slt: \"set on less than\" slt $t0, $s2, $s3 slt $t1, $s1, $s2 slt $t2, $s3, $s2 slti $t3, $s3, 10  #psuedoinstructions sle $t4, $s1, $s3 sle $t5, $s1, $s2 sgt $t6, $s3, $s2 ```       ## Shifting investigation     Execute it: what do `sll` and `srl` do?  What happens if you shift an odd number?  Are these R-Type or I-Type instructions?    ```mips .text   li $s0, 16  #shift left logical sll $t0, $s0, 1 sll $t1, $s0, 2  #shift right logical srl $t2, $s0, 2 ```        # Conditionals     ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```   ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-12-machine-code-logic-operations-and-conditionals/",
        "teaser": null
      },{
        "title": "Branching And Arrays",
        "excerpt":"# Branching and Arrays  ---  CS 130 // 2023-09-14       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```       ## Compiling a `while` Statement  ```python i = 1 while i != 10:      print(i)    i += 1 ```  ---  ```mips .text \tli $s0, 1 \tli $t0, 10 \t start_loop: \tbeq $s0, $t0, done  \tli $v0, 1 #print integer - no newline after! \tadd $a0, $s0, $zero #copy $s0 into $a0 \tsyscall  \taddi $s0, $s0, 1 \tb start_loop  done: ```      ## Exercise  - Translate this into MIPS - Hint: can you use `slt` here?  ```python sum = 0 i = 0  while i     ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has both an if statement and a loop    # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2023/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data   my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"       .text  \tla $s0, my_array #load the base address of the array \tli $t0, 0 #loop counter  loop:  \tslti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-14-branching-and-arrays/",
        "teaser": null
      },{
        "title": "Arrays And Procedures",
        "excerpt":"# Arrays and Procedures  ---  CS 130 // 2023-09-19     ![CS Tutoring information](/Fall2023/CS130/assets/CS_Tutoring_Flyer.png)     # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2023/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data   my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"       .text  \tla $s0, my_array #load the base address of the array \tli $t0, 0 #loop counter  loop:  \tslti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array      # Procedures     ### Compile a Simple Leaf Procedure  ```python def func(x,y):     return x + y ```  ---  ```mips func: add $v0, $a0, $a1       jr  $ra ```  * the first argument to the procedure is in `$a0` * the second argument to the procedure is in `$a1` * the return value of the procedure goes in `$v0` * `jr`: jump to the instruction whose address is in register `$ra`       ```mips func: add $v0, $a0, $a1       jr  $ra ```  When you call this function, you must * put the first argument in `$a0` * put the second argument in `$a1` * put the **return address** in `$ra` * jump to the function    ### Calling Our Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure      ### Nested Procedure Calls  ```python def main():     func(1, func(2, func(3, 4))) ```  ---  ```mips main:     li  $a0, 3     li  $a1, 4     jal func      li   $a0, 2     move $a1, $v0     jal  func      li   $a0, 1     move $a1, $v0     jal  func ``` **remember:** `$v0` is where we find the returned value       ## Calling a Procedure 1. Put parameters in appropriate registers     +   `$a0`, `$a1`, `$a2`, `$a3` 2.   Transfer control to the procedure: *jump and link*     +   `jal ProcedureLabel` \t- puts the current instruction's address into `$ra` 3.   Perform task 4.   Place result in a location the callee can find     +   `$v0`, `$v1` 5.   Return control to the caller: *jump to addr. in register*     +   `jr $ra`     ## Exercise - Convert the following Python code into MIPS - Make sure to create two functions     - make sure the print happens in `main`, not `double_it`  ```python def double_it(e):     return e + e  def main():     print( double_it(21) ) ```    ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-19-arrays-and-procedures/",
        "teaser": null
      },{
        "title": "Non Leaf Procedures And The Stack",
        "excerpt":"# Non-Leaf Procedures and The Stack  ---  CS 130 // 2023-09-21     # Review      ### Calling A Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` * `jr`: jump to the instruction whose address is in register `$ra` * `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure        ## Calling a Procedure 1. Put parameters in appropriate registers     +   `$a0`, `$a1`, `$a2`, `$a3` 2.   Transfer control to the procedure: *jump and link*     +   `jal ProcedureLabel` \t\t- puts the current instruction's address into `$ra` 3.   Perform task 4.   Place result in a location the callee can find     +   `$v0`, `$v1` 5.   Return control to the caller: *jump to addr. in register*     +   `jr $ra`     ## Non-Leaf Procedures - Life would be easy if all procedures were \"leaves\" - In reality, a procedure might call another procedure which may call another procedure ... \t- could even be *recursive* -   We need a way to preserve the state of each partially completed call so that they all return properly     # Stack     ## Stack - MIPS provides a register `$sp` that stores a memory address -   Addresses **above** `$sp` is memory that is already being used by other parts of the program -   Addresses **below** `$sp` is free memory    ## Stack - The **called** procedure is responsible for restoring any saved registers `$s0`, ..., `$s7` as well as the stack pointer `$sp` register before returning -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call    ## Memory Structure ![MIPS memory structure](/Fall2023/CS130/assets/images/COD/mips-memory.png)    ## Stack Frames ![Procedure frame](/Fall2023/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following C code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: Compute  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 4](../../assignments/assignment-4/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.  ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-21-non-leaf-procedures-and-the-stack/",
        "teaser": null
      },{
        "title": "Logic Gates And Truth Tables",
        "excerpt":"## Logic Gates and Truth Tables  ---  CS 130 // 2023-09-28    ### Preparing for next time  We will soon be using a digital logic simulator called Logisim-Evolution   * [Information here](https://github.com/logisim-evolution/logisim-evolution) * [Download here](https://github.com/logisim-evolution/logisim-evolution/releases)   - **jar** file: should work for anyone (similar to MARS)   - **msi** file: installer for Windows (you probably want x86 version)   - **dmg** file: installer for Mac (may or may not work on M1/M2/M3 Macs)     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2023/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. **Digital logic** 3. Processor architecture 4. The C Programming Language    ## Basic CPU Operations - Recall that most operations operate on one or more 32-bit registers     +   `add $s0,` `$s1`, `$s2` takes two 32-bit numbers, adds them up, and produces a new 32-bit number -   How can we build a machine that takes 0s and 1s as input and produces 0s and 1s as output?    # Digital Logic   NOTE: Discuss how hard electrical engineering is and why it is so useful to focus on the simplicity of digital logic    ## Transistors - CPU instructions are implemented with nanoscale switches called **transistors**     ![Light bulb](https://makercise.com/wp-content/uploads/2015/11/vlcsnap-2015-11-17-20h50m57s882.png.jpg)       You can think of a transistor as a \"switch\" with states \"on\" and \"off\"         ## Digital Logic - Learning about electricity, capacitors, resistors, is beyond the scope of this course -   For now, it is useful to abstract away the details of electrical engineering -   We will think about circuits in terms of 0s and 1s going through the wires of a circuit    ## Input/Output as Voltages    - The 0s and 1s of our circuits will be \"low\" and \"high\" voltages across a wire, similar to a light bulb being \"on\" and \"off\"     ![Bits as light bulbs](https://miro.medium.com/max/2400/1*Um-qKrB2QLxRU0C8CkCCeg.png)        ## Logic Gates - A **logic gate** is an elementary circuit that takes one or more bits as input and produces one or more bits as output -   Many of these logic gates can be constructed with one or two transistors    ## AND Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       0                 1       0       0                 1       1       1           ![AND Gate](/Fall2023/CS130/assets/images/gates/and.png)    ## OR Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       1            ![OR Gate](/Fall2023/CS130/assets/images/gates/or.png)      ## NOT Gate                 Input       Output                 0       1                 1       0           ![NOT Gate](/Fall2023/CS130/assets/images/gates/not.png)      ## NAND Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       1                 1       0       1                 1       1       0           ![NAND Gate](/Fall2023/CS130/assets/images/gates/nand.png)     ## NOR Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       0                 1       0       0                 1       1       0           ![NOR Gate](/Fall2023/CS130/assets/images/gates/nor.png)     ## XOR Gate                  Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       0           ![XOR Gate](/Fall2023/CS130/assets/images/gates/xor.png)  (exclusive OR)    ### Demo: What is the truth table for the following circuit?  ---     ![Simple circuit](/Fall2023/CS130/assets/images/gates/simple-circuit.png)                    A       B       C       D                 0       0       0                         0       0       1                         0       1       0                         0       1       1                         1       0       0                         1       0       1                         1       1       0                         1       1       1                         #### Exercise   1. Fill out the truth table 2. Describe what the circuit does using words      ![Simple circuit](/Fall2023/CS130/assets/images/gates/xorcise.png)                    A       B       C                 0       0                         0       1                         1       0                         1       1                       *NB:* a filled dot where wires cross means that the wire splits. If no dot appears, it means one wire is routed over the top of the other.    ### Symbolically describing a circuit         ![Simple circuit](/Fall2023/CS130/assets/images/gates/simple-circuit.png)           $$D = \\overline{(A\\cdot B)} + (B \\cdot C)$$      - $\\overline{A}$ \"not $A$\" - $\\cdot$ \"and\" - $+$ \"or\"    ### Exercise  Symbolically describe the circuit  ![Simple circuit](/Fall2023/CS130/assets/images/gates/xorcise.png)    ### Exercise  1. Draw a circuit representing the logic symbols 2. Write the truth table for the circuit  $$ C = (A \\cdot S) + (B \\cdot \\overline{S}) $$    ### Challenge Exercise       Can you come up with a circuit that has this truth table? - A, B, and C are inputs - E is an output  Verbally describe what this circuit does.   Write the logic symbols representing this circuit.                    A       B       C       E                 0       0       0       0                 0       0       1       1                 0       1       0       1                 0       1       1       0                 1       0       0       1                 1       0       1       0                 1       1       0       0                 1       1       1       1              ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-09-28-logic-gates-and-truth-tables/",
        "teaser": null
      },{
        "title": "Combinational Logic",
        "excerpt":"# Combinational Logic  ---  CS 130 // 2023-10-03    # Digital Logic Review         ### Who came up with these logic gate diagrams?  https://hsm.stackexchange.com/questions/3037/the-origin-of-logic-gate-symbols - in short: we're not sure  - they probably developed by convention over time    A student told me that he saw something that traced them back to George Boole - the inventor of Boolean Algebra     ## Boolean Algebra - We can represent logic gate computations as using **Boolean algebra** -   $\\overline{A}\\cdot B+A\\cdot C$ means the same thing as:     + `((not A) and B) or (A and C)`    ## Universal Gates - The **NAND** gate and the **NOR** gate are \"universal\" and can be used to construct every other gate - Using only **NAND** gates, construct circuits that are equivalent to NOT, AND, and OR gates  ![NOT from NAND](/Fall2023/CS130/assets/images/NOT_from_NAND.png) ![AND from NAND](/Fall2023/CS130/assets/images/AND_from_NAND.png) ![OR from NAND](/Fall2023/CS130/assets/images/OR_from_NAND.png)    ### Multiplexor From Last Time        $$ C = (A \\cdot S) + (B \\cdot \\overline{S}) $$  ![Multiplexor Circuit Diagram](/Fall2023/CS130/assets/images/multiplexor_diagram.png)                     A       B       S       C                 0       0       0       0                 0       0       1       0                 0       1       0       1                 0       1       1       0                 1       0       0       0                 1       0       1       1                 1       1       0       1                 1       1       1       1                 #### Demo: Designing and Testing Circuits with Logisim  [Installing Logisim](../../resources/installing-logisim/)  ![Multiplexor Circuit Diagram](/Fall2023/CS130/assets/images/logisim_multiplexor.png)     # Combinational Logic     ## Combinational Logic - **Combinational** logic circuits don't have memory     +   Output depends on only the input     +   Can be completely specified by a truth table -   **Sequential** logic circuits do have memory     +   Output depends on both the input and current state of memory    ## Sum of Products Form - All combinational circuits can be converted to a **sum of products** form that makes them especially easy to implement with gates  ---     -   Need to identify the 1s in the output -   Construct a product term such as $\\overline{A}\\cdot\\overline{B}\\cdot C$ for each 1 in output -   \"Sum\" them together             A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ### Example       $\\overline{A}\\cdot\\overline{B}\\cdot C$  + $\\overline{A}\\cdot B\\cdot \\overline{C}$   +  $A \\cdot \\overline{B}\\cdot \\overline{C}$   +  $A \\cdot B \\cdot C$                 A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ## Exercise: Sum of Products                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1           - Write-out the sum-of-products for this truth table    + Inputs are A, B, C.     + Outputs are Y1, Y0   - Draw the circuit by hand   - Draw the circuit in Logisim    + Manually test some inputs   - Create a run test vector     *NB:* circuits built from the sum-of-products have two stages - ANDs then ORs   - this is called a **programmable logic array** or PLA        ## Assignment  - [Assignment 5](../../assignments/assignment-5/)   - Given a truth table, design a circuit   - Use sum-of-products   - implement it in Logisim   - test it with a test vector   - submit screenshot      ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png)   ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-03-combinational-logic/",
        "teaser": null
      },{
        "title": "Constructing A Basic Alu",
        "excerpt":"## Constructing an Adder and an ALU  ---  CS 130 // 2023-10-05     # One-bit Adder     #### Full Adder: Circuit that adds three bits                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1                   ![Full Adder](../../assets/images/combinational_FA.png)             # Four-bit Adder     ## Demo: constructing a 4-bit adder from 1-bit full adders  ![4 Bit Adder](../../assets/images/adder4bits.png)  [Adder test vector](../../assets/adder4bit_test_vector.txt)     # ALU     ## The ALU - What does ALU stand for?     + Arithmetic Logic Unit -   What does an ALU do?     + Does all the logical and arithmetic operations of the CPU    ## Basic ALU - The simplest ALU conceivable is one that only operates on two 1-bit inputs and can perform only two operations: **AND** and **OR**     ```py     def basic_alu(a, b, op):         if op == \"0\":             return (a and b)         else:             return (a or b)     ``` -   Let's implement this in Logisim!    ### Exercise: Enhance the Basic ALU 1. make it work on 4-bit values 2. add operations for XOR and NOT  - you will need a bigger multiplexor  - NOT only works on **A** - ignore **B** 3. Can you include your 4-bit adder?     # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 1  ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-05-constructing-a-basic-alu/",
        "teaser": null
      },{
        "title": "Subtraction Sequential Logic",
        "excerpt":"# Subtraction, Sequential Logic  ---  CS 130 // 2023-10-10    ## Schedule Change  Exam 2 will be due Tuesday, October 24th - pushed back one class meeting * Asynchronous * Exam workday will be on October 24th   # Review: Adder and ALU Start     ## 4-Bit Adder and a Start to an ALU     ![4 Bit Adder](../../assets/images/adder4bits.png)      ![4 Bit Adder](../../assets/images/alustart.png)        # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 0    ## Exercise  - Work on getting subtraction and `slt` working in your 4-bit ALU    ## Assignment  - [Assignment 6](../../assignments/assignment-6/)   - make a 32-bit ALU   - `add`, `sub`, `and`, `or`, `not`, `xor`, `slt`, and anything else you want   - you can use Logisim's built-in components   - try not to duplicate circuitry for `add`, `sub`, and `slt`.   - submit screenshots of circuits *and* test vector (with comments)    # Sequential Logic     ## Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## S-R Latch     - A \"set reset\" latch is implemented with      - Let's fill in the truth table together              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 01      0 0 10      1 0 01      1 0 10      0 1 01      0 1 10           ## D Latch     - A \"data\" latch is implemented with      - Let's fill in the truth table together               $C$$D$$Q_\\text{next}$      0 0       0 1       1 0       1 1            ## Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-writing.png) ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-10-subtraction-sequential-logic/",
        "teaser": null
      },{
        "title": "Sequential Logic",
        "excerpt":"# Sequential Logic  ---  CS 130 // 2023-10-12    # Sequential Logic     ## Review: Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## Review: S-R Latch     - A \"set reset\" latch is implemented with      - S = 1 $\\rightarrow$ change Q to 1 - R = 1 $\\rightarrow$ change Q to 0 - S = R = 0 $\\rightarrow$ leave Q as is              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 0101      0 0 1010      1 0 0110      1 0 1010      0 1 0101      0 1 1001           ## Review: D Latch     - A \"data\" latch is implemented with      - Only allow change when C is 1 (get next value from D)              $C$$D$$Q_\\text{next}$      0 0$Q$      0 1$Q$      1 00      1 11           ## Review: Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-writing.png)    ## Exercise: Build a register File in Logisim     - 32 bits - at least 4 registers   ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file.png)      ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-writing.png)  ![Register File Diagram](/Fall2023/CS130/assets/images/COD/register-file-reading.png)   ![register file glimpse](../../assets/images/register_file_glimpse.png)      ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-12-sequential-logic/",
        "teaser": null
      },{
        "title": "Memory",
        "excerpt":"# Memory   ---  CS 130 // 2023-10-19     # Review     ## Sequential Logic - **Sequential** logic circuits have memory     +   Output depends on both the input and current state of memory     +   Behavior can change **over time**    ### Sequential Logic Components - **Clock**: a signal that oscillates between 0 and 1 -   **Latch**: 1-bit memory element that is updated when the clock is 1 -   **Flip Flop**: 1-bit memory element that is updated when the clock transitions from a 1 to a 0 -   **Register**: multi-bit memory unit (32 or 64 bits) that consists of an array of flip flops or latches -   **Register Files**: An array of registers     # ROM      ## ROM: Read-Only Memory   - Intended only to be read from (though it may be possible to change it in some circumstances) - **Non-volatile**: keeps its value without power - Game Cartidges, CD-ROM, DVD - Firmware for PCs and other devices   + contains boot-up instructions  ![CD ROM](../../assets/images/CD-ROM.png)  ![game cartridge](../../assets/images/gamecartridge.jpg)     # RAM     ## RAM: Random Access Memory - It takes the same amount of time to access data regardless of where it is   ![RAM modules](../../assets/images/ram.jpg)      ## Static Random Access Memory - Memory where data is stored *statically* with flip-flops - Faster than DRAM but less dense (lower capacity) and more expensive per bit - As long as it has power, SRAM will keep its value - Usually used for cache memory    ## Dynamic Random Access Memory - DRAM is the most dense RAM     * Implemented with capacitors instead of latches - stores energy in an electrical field - Must be occasionally \"refreshed\" because the capacitors slowly lose their stored values     * This is why it is called \"dynamic\" - Usually used for large capacity RAM    ## Instruction Memory on the CPU  ![Instruction Fetch](/Fall2023/CS130/assets/images/COD/instruction_fetch.png)    ## Demo: Make it in Logisim       Use a ROM to simulate instruction memory  - 16 bit address (should be 32 for MIPS, but that is too big for Logisim) - Quad output - so we can read four bytes at a time - lowest-address byte is shown first in Logisim memory contents      ![MIPS program in Logisim](../../assets/images/mips-for-logisim-rom.png)   ![MIPS program in MARS](../../assets/images/mips-for-logisim-mars.png)          ## Exercise    - Create a Program Counter Register which iterates through the instructions in memory   ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)    ## Exercise   - You can set your splitter to have custom fan-out ranges - Make a separate pin for each instruction field (opcode, rs, rt, etc.)       ![Custom Ranges for Splitter](../../assets/images/custom-splitter.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)    ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-19-memory/",
        "teaser": null
      },{
        "title": "The Datapath",
        "excerpt":"# The Datapath  ---  CS 130 // 2023-10-26     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2023/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. Digital logic 3. **Processor architecture** 4. The C Programming Language    # Review      ## Review   - **CPU:** Central Processing Unit   - the circuits that execute instructions from a program   - AKA \"the processor\"   - Processor architecture   - logical design of CPU    - how do memory, the ALU, Register File, etc. all fit together?    ![Photo of the inside of a laptop](/Fall2023/CS130/assets/images/COD/inside-laptop.png)    ![Components of a processor](/Fall2023/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2023/CS130/assets/images/COD/control.png)      # The Datapath     ## The Datapath - What is a \"datapath\" and what does it consist of?     +   It is the main component of the CPU that executes instructions     +   Fetches instructions and data from memory, performs arithmetic, etc.     +   Consists of ALUs, a register file, RAM, and various supplementary logic gates    ## Instruction Execution 1. Uses the PC to fetch the next instruction to be executed from memory 2.   Identifies instruction type and registers involved and fetches their contents from the register file 3.   Depending on the instruction:     -   Uses the ALU to do appropriate arithmetic     -   Read/write RAM for load/store     -   Update PC to PC + 4 or the jump target address    # Building a Datapath     ## Instruction Fetch  ![Instruction Fetch](/Fall2023/CS130/assets/images/COD/instruction_fetch.png)    ## Review: Handling Instruction Fetch - We started this in Logisim  ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)      ## Decoding the Instruction   - You can set your splitter to have custom fan-out ranges      ![Decode Step](../../assets/images/decode.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)        ## Decode close-up  ![Decode Step Zoomed In](../../assets/images/decodezoom.png)     ## R-Format Instructions  - Read two register operands, perform ALU operation, write result to target register  ![R-Format Instructions](/Fall2023/CS130/assets/images/COD/r_format_instructions.png)    ## Inputs to the Register File  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register Inputs](../../assets/images/reg_inputs.png)     [Logisim Register File and ALU](https://ericmanley.github.io/Fall2023/CS130/assets/RegisterFileAndALU.circ)     ## Connecting it to the ALU  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register and ALU](../../assets/images/reg_file_outputs.png)     ## Walking an instruction through the datapath   ```mips  add $10, $8, $9 ```  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   000000 01000 01001 01010 00000 100000  ![Register and ALU](../../assets/images/reg_file_outputs.png)      ## Exercise  How can we handle I-type instructions like   ```mips  addi $8, $0, 5 ```  ![I-Type format](../../assets/images/COD/i-type-instruction.png)   001000 00000 01000 0000000000000101  ![Register and ALU](../../assets/images/reg_file_outputs.png)     ## Load/Store Instructions  - Read register operands, calculate address, read/write to memory  ![Load-Store Instructions](/Fall2023/CS130/assets/images/COD/load_store_instructions.png)    ## Branch Instructions  - Read register operands, compare operands, calculate target address    ![Branch Instructions](/Fall2023/CS130/assets/images/COD/branch_instructions.png)    ## The Full Datapath    ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-26-the-datapath/",
        "teaser": null
      },{
        "title": "Control",
        "excerpt":"# Control  ---  CS 130 // 2023-10-31     ## Revert to previous version of Logisim  Some of what we do today is broken in the current version of Logisim (3.8).   Install the previous version, 3.7.2 here:   https://github.com/logisim-evolution/logisim-evolution/releases/tag/v3.7.2     # Review      ## MIPS CPU Diagram  ![Processor component diagram](/Fall2023/CS130/assets/images/COD/control.png)      ## progress from last time  ![Logisim Datapath Design](/Fall2023/CS130/assets/images/datapath_no_control.png)   - I added input and output pins so we can select a register to be displayed      # Controlling CPU components     ### Group Discussion  ![Logisim Datapath Design](/Fall2023/CS130/assets/images/datapath_no_control.png)  - Which inputs haven't we hooked up yet? - What do these all have in common? - What part of the instruction format will tell us what these things need to be set to?     ## Control Behavior for add  ```mips  add $10, $8, $9 ```  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   000000 01000 01001 01010 00000 100000  - When opcode is 000000 and funct is 100000...  - set ALUop to 000 (may be different for your ALU!)  - set RegWrite to 1  - set IType to 0    ## Control Behavior for addi   ```mips  addi $8, $0, 5 ```  ![I-Type format](../../assets/images/COD/i-type-instruction.png)   001000 00000 01000 0000000000000101  - When opcode is 001000  - set ALUop to 000 (may be different for your ALU!)  - set RegWrite to 1  - set IType to 1    ## Control Unit Design  - output depends on input $\\Rightarrow$ combinational circuit - can design a truth table, do sum of products, and make a PLA - Now that we know how to do it - let's let Logisim automate it for us!    Start of a truth table for our control unit:   ``` opcode[5..0] funct[5..0] | ALUop[2..0] RegWrite IType 000000       100000      | 000         1        0      #add 001000       xxxxxx      | 000         1        1      #addi ```  save this to file `control_specification.txt`    ## Logisim directions      - Add a new circuit to your project, call it **control** - *Project* $\\rightarrow$ *Analyze Circuit* - Click *Import Table* button - Select your `control_specification.txt` file  - This will give you a warning - say *Yes* to ignore the errors and try again     ![Logisim load truth table](../../assets/images/circuit_from_truth_table.png)        - Click the *Build Circuit* button - Review and make sure you are not overwriting a different circuit in your project  - Click *OK*  ![build circuit](../../assets/images/build_circuit.png)     ## Hook it up to the datapath  ![Datapath with Control in Logisim](../../assets/images/logisim_cpu_simulated.png)   - simulate it  - use the **viewRegisterNum** and **RegisterContents** pins to see the values of registers as it executes    ## Exercise   - Update your Control Unit so that it works with   - `sub`   - `andi`  - [Assignment 7](../../assignments/assignment-7/): do these too   - `and`, `xor`, `andi`, `ori`, `xori`, `slt`, `slti`      # Supporting More Instructions     ## Load Instruction  Let's describe what happens for a load operation like  ```mips  lw $8, 4($9) ```  100011 01001 01000 0000000000000100  ![Processor component diagram](/Fall2023/CS130/assets/images/COD/full_datapath.png)       ## Exercise: Store Instruction  Describe what happens for a store operation like  ```mips  sw $8, 4($9) ```  101011 01001 01000 0000000000000100  ![Processor component diagram](/Fall2023/CS130/assets/images/COD/full_datapath.png)       ## Exercise: Branches  Describe what happens for a branch instruction like  ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101  ![Processor component diagram](/Fall2023/CS130/assets/images/COD/full_datapath.png)     ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-10-31-control/",
        "teaser": null
      },{
        "title": "Instruction Execution Stages",
        "excerpt":"# Instruction Execution Stages  ---  CS 130 // 2023-11-02    # Datapath and Control Review     ## Review: Datapath with Control      #### Breaking down instruction execution  - Five stages:     1. **IF**: Instruction Fetch       - read it from instruction memory     2. **ID**: Instruction Decode and Register Read      - split instruction into parts, read register data     3. **EX**: Execute      - ALU calculates result      4. **MEM**: Memory Access      - we haven't done this yet!     5. **WB**: Write back      - put new data back into a register     ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - IF:   - ID:  - EX:  - MEM:   - WB:         ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - **IF:** PC provides instruction address, bit pattern 001000 00000 01000 0000000000000101 read from memory  - 4 added to PC      ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - **ID:** instruction bit pattern split apart into opcode (001000), rs (00000), rt (01000), contant (5). Opcode goes to Control Unit. Value 0 read from register $0 indicated by rs.         ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - **EX:** Value 0 (from $0) and 5 (from instruction constant) added together in ALU.   - ALUop set to \"add\" code  - ALUSrc set to 1  - Branch set to 0      ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - **MEM:** None  - MemRead and MemWrite both set to 0      ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           - **WB:** result from ALU (5), written to register $8 (specified by rt)  - RegWrite set to 1  - RegDst set to 0  - MemtoReg set to 0     # Supporting More Instructions     ## Load Instruction  Let's describe what happens for a load operation like  ```mips  lw $8, 4($9) ```  100011 01001 01000 0000000000000100           - IF:   - ID:  - EX:  - MEM:   - WB:          ## Exercise: Store Instruction  Describe what happens for a store operation like  ```mips  sw $8, 4($9) ```  101011 01001 01000 0000000000000100           - IF:   - ID:  - EX:  - MEM:   - WB:          ## Exercise: Branches  Describe what happens for a branch instruction like  ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101           - IF:   - ID:  - EX:  - MEM:   - WB:          # Performance Issues     ## Performance Issues - Longest delay determines clock period -   Some stages of the datapath are idle waiting for others to finish -   Can improve performance by **pipelining**  ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-11-02-instruction-execution-stages/",
        "teaser": null
      },{
        "title": "Pipelining",
        "excerpt":"# Pipelining  ---  CS 130 // 2023-11-07     # Schedule Update      ## Schedule going forward   * Finish CPU Design this week  * Start C programming next week * When should we do the exam work day?     - Next week, T 11/14 before we start C      - Right before Thanksgiving, T 11/21 after we start C  Poll: https://forms.gle/RFQp4WpZ7cpk1bKeA    # Review     #### Breaking down instruction execution  - Five stages:     1. **IF**: Instruction Fetch       - read it from instruction memory     2. **ID**: Instruction Decode and Register Read      - split instruction into parts, read register data     3. **EX**: Execute      - ALU calculates result      4. **MEM**: Memory Access      - we haven't done this yet!     5. **WB**: Write back      - put new data back into a register       ## Branches  Describe what happens for a branch instruction like  ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101           - IF:   - ID:  - EX:  - MEM:   - WB:          # Performance Issues     ## Performance Issues - Longest delay determines clock period -   Some stages of the datapath are idle waiting for others to finish -   Can improve performance by **pipelining**    # Pipelining     ## Pipeline Analogy - Suppose you need to do four loads of laundry -   Each load of laundry needs to be     1. Washed via the washing machine     2. Dried via the dryer     3. Folded     4. Put away in the closet -   For simplicity, assume that each task takes 30 mins    ## Pipeline Analogy - How long does it take to complete four loads? -   One approach uses only one stage at a time and does nothing in parallel:     ![nonpipelined_laundry](/Fall2023/CS130/assets/images/COD/unpipelined_laundry.png) -   Notice that the washer is unused 3/4 of the time    ## Pipeline Analogy - Another approach is harnessing parallelism by running independent stages simultaneously     ![pipelined_laundry](/Fall2023/CS130/assets/images/COD/pipelined_laundry.png) -   How much of a speedup does this approach give us?     +   $8/3.5 = 2.3\\times$ speedup     +   $2n/0.5n = 4\\times$ speedup if running continuously    ## Pipelined Datapath      ## Pipelined Datapath - Five stages:     1. **IF**: Instruction Fetch     2. **ID**: Instruction Decode     3. **EX**: Execute     4. **MEM**: Memory access     5. **WB**: Write back    ## Pipeline Performance - Assume time for stages is:     + `$100\\text{ps}$` for register read/write     + `$200\\text{ps}$` for other stages  ![Pipeline Performance](/Fall2023/CS130/assets/images/COD/pipeline_performance_table.png)     ## Without a Pipeline ![Pipeline Performance](/Fall2023/CS130/assets/images/COD/nonpipelined_mips_instructions.png)  - Why must the clock be set to `$800\\text{ps}$` when some instructions like `beq` could be completed in `$500\\text{ps}$`?     +   Clock speed is limited by **slowest** instruction: `lw`    ## With a Pipeline ![Pipeline Performance](/Fall2023/CS130/assets/images/COD/pipelined_mips_instructions.png)  -   How much of a speedup does this approach give us?     +   `$2400/1400 = 1.7\\times$` speedup     +   `$800n/200n = 4\\times$` if running continuously    ## Pipeline Performance - Does using a pipeline increase the efficiency of executing **individual** instructions?     +   No, it slows them down from `$800\\text{ps}$` to `$1000\\text{ps}$`     +   Performance benefits come from increased **throughput** due to the parallelism    ## Why MIPS is Good for Pipelining - All MIPS instructions are the **same length**     + Easy to fetch instruction in cycle 1     + Easy to decode instruction in cycle 2 -   MIPS has only **a few instruction formats**     + Registers will always be in same location     + Easy to decode instructions    # Hazards     ## Hazards - Up until now, we have pretended that each instruction is **independent** of the others and that there are no conflicts -   In reality, instructions often depends on previous ones, which may cause naive pipelining to fail    ### Exercise  ```mips add $s0, $t0, $t1 sub $t2, $s0, $t3 ``` - What stage does `add` write the result of `$s0` into the register file?  - What stage does `sub` read from `$s0`?  - Why is this a problem?  - Can you think of any ways to fix this?    ## Types of Hazards - Situations that prevent immediately executing the next instruction in the pipeline are called **hazards** -   Three types of hazards:     1. Structure hazards     2. Data hazards     3. Control hazards    # Structure Hazards     ## Structure Hazards - In our laundry example, we were assuming the \"fold\" and \"put away\" stages could be done simultaneously     + However, if you are working by yourself, you would have to do them sequentially -   A **structure hazard** occurs when a required resource is busy performing another task    ## Structure Hazards - Recall that our MIPS pipeline has five stages:     + IF, ID, EX, MEM, WB -   The ID and WB stages read and write to the register file simultaneously     + Does this create a structure hazard?     +   No, by design, the register file supports simultaneous reading and writing    ## Structure Hazards - Suppose that we stored instruction memory and data memory in the same location     + Would this create a structure hazard?     +   Yes, the IF and the MEM stages would need to simultaneously read from the same memory     +   If using a single memory, the pipeline would need to **stall** to wait for the resource to become available    # Data Hazards     ## Data Hazards - A **data hazard** occurs when one instruction depends on the result of a previous instruction -   Our example:     ```mips     add $s0, $t0, $t1     sub $t2, $s0, $t3     ``` -   What stage does `add` write the result of `$s0` into the register file?     +   Stage 5: Write Back -   What stage does `sub` read from `$s0`?     +   Stage 2: Instruction Decode    ## Data Hazards - Would need to stall for two clock cycles in order to wait for the value $s0 to be available for reading  ![Data Hazard Stall](/Fall2023/CS130/assets/images/COD/data_hazard_stall.png)    ## Forwarding (aka Bypassing) - One way to avoid some data hazards without stalling is to **forward** the result to the next instruction immediately when it is available  ![Data Hazard Forwarding](/Fall2023/CS130/assets/images/COD/data_hazard_forwarding.png)    ### Discuss: What does this look like on the datapath?      ![Data Hazard Forwarding](/Fall2023/CS130/assets/images/COD/data_hazard_forwarding.png)             ## Forwarding (aka Bypassing) - Can you think of a situation where forwarding cannot resolve a data hazard?     ```mips     lw $s0, 20($t1)     sub $t2, $s0, $t3     ``` -   What stage does `lw` produce the bits of `$s0`?     +   After Stage 4: MEM    ## Forwarding (aka Bypassing)  - Why does this create an unavoidable stall?     ![Data Hazard Load Stall](/Fall2023/CS130/assets/images/COD/data_hazard_load.png)  -   We cannot send data **backwards in time**     ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` -   Assuming there is no forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code without forwarding?    ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` - Assuming there IS forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code with forwarding?    ## Rearranging Instructions - Another way to avoid data hazards is by rearranging instructions - Consider the following MIPS code:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     lw  $t4, 8($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ``` -   Identify any stalls that are necessary even with forwarding and hazard detection active    ## Rearranging Instructions - These two stalls could be avoided by rearranging the code in the following way:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     lw  $t4, 8($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ```    # Control Hazards     ## Control Hazards - A **control hazard** (aka branching hazard) is when the next instruction to be executed is not yet known -   Caused by **branching** instructions such as `beq` -   During a `beq` instruction, at what pipeline stage do we know which branch will be taken?     +   After Stage 3: EX    ## Control Hazards - One way to avoid control hazards is by stalling     ![Stall on Branch](/Fall2023/CS130/assets/images/COD/stall_on_branch.png) -   After every branch statement, we stall for one cycle    ## Control Hazards - The pros of the \"always stall\" approach are:     1.   Simple and easy to understand     2.   Will always work -   The con of \"always stall\" is:     + It is slow    ## Control Hazards - An alternative to the always stall approach is **branch prediction**     + Make an educated guess on what the next instruction will be and execute that     +   If incorrectly guessed, \"undo\" the steps and go to the correct branch    ## Control Hazards - **Static branch prediction** will always predict a certain branch depending on the branching behavior     +   Predict forward branches not taken     +   Predict backward branches taken (loops) -   **Dynamic branch prediction** keeps track of how many times a branch is taken and updates its predictions based on history    # Pipelined Datapath Design     ## Pipelined Datapath Design     ## Using Registers (Has Bug)     ## Using Registers (Bug Fixed)      # Pipelined Control     ## Pipelined Control Simplified  ![Pipeline Control Simplified](/Fall2023/CS130/assets/images/COD/pipelined_control_simplified.png)    ## Pipelined Control Registers - Control signals derived from instruction and passed through the relevant registers  ![Pipeline Control Registers](/Fall2023/CS130/assets/images/COD/pipelined_control_registers.png)    ## Pipelined Control Complete      ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-11-07-pipelining/",
        "teaser": null
      },{
        "title": "Pipeline Hazards And Cache",
        "excerpt":"# Pipeline Hazards And Cache  ---  CS 130 // 2023-11-09     # Announcements       ## Installing stuff for C programming   Before you come to class next week: [install guide](../../resources/installing-visual-studio-code)   - install Visual Studio Code (IDE for writing code)   - install C/C++ extensions for VSC    - install a C compiler   - try compiling a C program   - do your best to troubleshoot issues   - bring any remaining issues to class       ## Exam 3 has been posted   - Due 11/21/2023 (Tuesday before Thanksgiving) - Class on 11/21/2023 is an exam work day - no class meeting - I'm giving you a lot of time - please plan ahead and give yourself time to complete it     # Review     ## Review Discussion  - what is pipelining? - what is a pipeline hazard? - what are the different types of pipeline hazards? - what are some ways to deal with pipeline hazards?     ## Review: Data Hazards - A **data hazard** occurs when one instruction depends on the result of a previous instruction -   Our example:     ```mips     add $s0, $t0, $t1     sub $t2, $s0, $t3     ``` -   What stage does `add` write the result of `$s0` into the register file?     +   Stage 5: Write Back -   What stage does `sub` read from `$s0`?     +   Stage 2: Instruction Decode    ## Data Hazards - Would need to stall for two clock cycles in order to wait for the value $s0 to be available for reading  ![Data Hazard Stall](/Fall2023/CS130/assets/images/COD/data_hazard_stall.png)    ## Forwarding (aka Bypassing) - One way to avoid some data hazards without stalling is to **forward** the result to the next instruction immediately when it is available  ![Data Hazard Forwarding](/Fall2023/CS130/assets/images/COD/data_hazard_forwarding.png)    ### Discuss: What does this look like on the datapath?      ![Data Hazard Forwarding](/Fall2023/CS130/assets/images/COD/data_hazard_forwarding.png)             ## Forwarding (aka Bypassing) - Forwarding cannot always resolve a data hazard     ```mips     lw $s0, 20($t1)     sub $t2, $s0, $t3     ``` - What stage does `lw` produce the bits of `$s0`?     +   After Stage 4: MEM    ## Forwarding (aka Bypassing)  - Why does this create an unavoidable stall?     ![Data Hazard Load Stall](/Fall2023/CS130/assets/images/COD/data_hazard_load.png)  -   We cannot send data **backwards in time**     ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` -   Assuming there is no forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code without forwarding?    ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` - Assuming there IS forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code with forwarding?    ## Rearranging Instructions - Another way to avoid data hazards is by rearranging instructions - Consider the following MIPS code:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     lw  $t4, 8($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ``` -   We need to stall the first add (because it needs `$t2`) -   We need to stall the second add (because it needs `$t4`)    ## Rearranging Instructions - These two stalls could be avoided by rearranging the code in the following way:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     lw  $t4, 8($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ```     # Control Hazards     ## Control Hazards - A **control hazard** (aka branching hazard) is when the next instruction to be executed is not yet known -   Caused by **branching** instructions such as `beq` -   During a `beq` instruction, at what pipeline stage do we know which branch will be taken?     +   After Stage 3: EX    ## Control Hazards - One way to avoid control hazards is by stalling     ![Stall on Branch](/Fall2023/CS130/assets/images/COD/stall_on_branch.png) -   After every branch statement, we stall for one cycle    ## Control Hazards - The pros of the \"always stall\" approach are:     1.   Simple and easy to understand     2.   Will always work -   The con of \"always stall\" is:     + It is slow    ## Control Hazards - An alternative to the always stall approach is **branch prediction**     + Make an educated guess on what the next instruction will be and execute that     +   If incorrectly guessed, \"undo\" the steps and go to the correct branch    ## Control Hazards - **Static branch prediction** will always predict a certain branch depending on the branching behavior     +   Predict forward branches not taken     +   Predict backward branches taken (loops) -   **Dynamic branch prediction** keeps track of how many times a branch is taken and updates its predictions based on history     # Pipelined CPU Design      ## Pipelined Control Complete       ### Pipelined Architecture with Hazard Detection and Forwarding         # Caches     ## Memory Organization - When a program uses memory, it tends to use it in *predictable ways*  -   As a result, it is possible to speed up memory usage dramatically by creating a **memory hierarchy**     +   Register file is small but it's ridiculously fast     +   SRAM is larger but slower     +   DRAM is larger still but even slower     +   Hard disks are HUGE but also the slowest    ## Terminology - **Cache:**     + An auxiliary memory from which high-speed retrieval is possible -   **Block:**     + A minimum unit of information that can either be present or not present in the cache -   **Hit:**     + CPU finds what it is looking for in the cache -   **Miss:**     + CPU doesn't find what it's looking for in the cache     ## Designing a Cache - Having a hierarchy of memories to speed up our computations is great, but we also face several design challenges -   If we are looking for a value in memory address `x`, how do we know if it is already in the cache?    ## Direct  Mapped Cache - One idea is to use a **direct mapped cache** where the address `$x_n$` tells us where to look in the cache -   If there are `n` slots in the cache, then we look for `x` in the `x % n` index of the cache    ## Direct Mapped Cache  ![Direct Mapped Cache](/Fall2023/CS130/assets/images/COD/direct_mapped_cache.png)    ## Direct Mapped Cache - If the number of blocks in the cache is `$n = 2^k$`, then `(x % n)` is simply the last `k` bits of `x`     + Makes it extremely efficient to find where a block is in the cache -   Since multiple blocks may have the same index in the cache, how do we know if the block of memory there is the one we're looking for?     +   Include a **tag** that uniquely identifies the block    ## Direct Mapped Cache - Some parts of the cache can be empty and/or underutilized if their index, by chance, doesn't pop up as often -   How can we improve utilization?    ## Fully Associative Cache - The \"extreme\" alternative to direct mapped caching is **fully associative** caching     + Any block can be stored in *any* index of the cache  ---  -   **Advantage**: Every spot in the cache will be used, and therefore less cache misses will occur -   **Disadvantage**: We need to search the entire cache every time, so the hit time will increase    ## Set-Associative Cache - The compromise between these approaches is the **set-associative** cache     + Blocks are *grouped* into sets of `n` blocks     + Block number determines which set -   Still requires searching through all `n` blocks in a set -   Can be tuned to have a decent balance between hit rate and hit time         ## Handling a Cache Miss 1. Check the cache for a memory address     + Results in a miss 2.   Fetch corresponding block from RAM or disk     + Wait for block to be retrieved (stall)     +   Write block to cache 3.   Continue pipeline (unstall)        ## Multilevel Caches - Usually, caches are implemented in multiple \"levels\" for maximal efficiency     +   L1 is smallest/fastest     +   L2 is larger/slower     +   L3 is largest/slowest -   Modern multi-core processors typically have dedicated L1 and L2 caches for each core and a shared L3 cache ","categories": [],
        "tags": [],
        "url": "/Fall2023/CS130/slides/2023-11-09-pipeline-hazards-and-cache/",
        "teaser": null
      }]
