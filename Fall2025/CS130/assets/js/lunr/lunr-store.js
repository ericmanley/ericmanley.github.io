var store = [{
        "title": "The Datapath",
        "excerpt":"# The Datapath  ---  CS 130 // 2024-10-24     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. Digital logic 3. **Processor architecture** 4. The C Programming Language    # Review      ## Review   - **CPU:** Central Processing Unit   - the circuits that execute instructions from a program   - AKA \"the processor\"   - Processor architecture   - logical design of CPU    - how do memory, the ALU, Register File, etc. all fit together?       ![Photo of the inside of a laptop](/Fall2025/CS130/assets/images/laptop-internal-components.png)  image from https://www.scientecheasy.com/2024/09/laptop-components.html/    ![Components of a processor](/Fall2025/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)      # The Datapath     ## The Datapath - What is a \"datapath\" and what does it consist of?     +   It is the main component of the CPU that executes instructions     +   Fetches instructions and data from memory, performs arithmetic, etc.     +   Consists of ALUs, a register file, RAM, and various supplementary logic gates    ## Instruction Execution 1. Uses the PC to fetch the next instruction to be executed from memory 2.   Identifies instruction type and registers involved and fetches their contents from the register file 3.   Depending on the instruction:     -   Uses the ALU to do appropriate arithmetic     -   Read/write RAM for load/store     -   Update PC to PC + 4 or the jump target address    # Building a Datapath     ## Instruction Fetch  ![Instruction Fetch](/Fall2025/CS130/assets/images/COD/instruction_fetch.png)    ## Review: Handling Instruction Fetch - We started this in Logisim  ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)      ## Decoding the Instruction   - You can set your splitter to have custom fan-out ranges      ![Decode Step](../../assets/images/decode.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)        ## Decode close-up  ![Decode Step Zoomed In](../../assets/images/decodezoom.png)     ## R-Format Instructions  - Read two register operands, perform ALU operation, write result to target register  ![R-Format Instructions](/Fall2025/CS130/assets/images/COD/r_format_instructions.png)    ## Inputs to the Register File  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register Inputs](../../assets/images/reg_inputs.png)     [Logisim Register File and ALU](https://ericmanley.github.io/Fall2025/CS130/assets/RegisterFileAndALU.circ)     ## Connecting it to the ALU  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register and ALU](../../assets/images/reg_file_outputs.png)     ## Walking an instruction through the datapath   ```mips  add $10, $8, $9 ```  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   000000 01000 01001 01010 00000 100000  ![Register and ALU](../../assets/images/reg_file_outputs.png)      ## Exercise  How can we handle I-type instructions like   ```mips  addi $8, $0, 5 ```  ![I-Type format](../../assets/images/COD/i-type-instruction.png)   001000 00000 01000 0000000000000101  ![Register and ALU](../../assets/images/reg_file_outputs.png)     ## Load/Store Instructions  - Read register operands, calculate address, read/write to memory  ![Load-Store Instructions](/Fall2025/CS130/assets/images/COD/load_store_instructions.png)    ## Branch Instructions  - Read register operands, compare operands, calculate target address    ![Branch Instructions](/Fall2025/CS130/assets/images/COD/branch_instructions.png)    ## The Full Datapath    ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2024-10-24-the-datapath/",
        "teaser": null
      },{
        "title": "Lecture: Computer Organization",
        "excerpt":"# Computer Organization #### and Assembly Language Programming  ---  CS 130 // 2025-08-25    # Welcome! Instructor: Eric Manley  ---     **Office:** Collier-Scripps 327 **Email:**  **Phone:** (515) 271-2177     **Office Hours:** Schedule in [Calendly](https://calendly.com/eric-manley/) the day before or drop inMW 9:45-11:30am (tentative)         # Course Overview     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    So... what is a processor?     ![Photo of the inside of a laptop](/Fall2025/CS130/assets/images/COD/inside-laptop.png)    ![Components of a processor](/Fall2025/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)     ## Major Aspects of the Course 1. Assembly language programming 2.   Digital logic 3.   Processor architecture 4.  The C Programming Language     #### Why should I learn this stuff?  Let's start with three good reasons    #### Reason 1: Sometimes you really need to understand the system to solve your problems  There are issues related to performance and security that must be solved at *lower-levels of abstraction*     #### Example: Shazam - the transaction processing company  ![Transaction processing network](/Fall2025/CS130/assets/images/transaction-processing-network.png) - They hire developers in Des Moines - Need to process transactions fast  - If the Java garbage collector kicks in, they're in trouble     #### Reason 2: In the age of AI, being good at programming isn't good enough   [https://livebench.ai/](https://livebench.ai/)     Developers who will set themselves apart understand technological foundations, can design at higher levels, and can evaluated and refine what AI produces    #### Reason 3: How does magic *really* work in our world?        ![Door to Moria](/Fall2025/CS130/assets/images/moria-door.webp)   ![Mistborn novel cover](/Fall2025/CS130/assets/images/mistborn-book.jpg)      ![Dungeons and Dragons spells](/Fall2025/CS130/assets/images/phb-spells.jpg)             ### My background with this course  - 1996-2004: C/C++ was my _native_ language -   2001: I took a course in _assembly_ and _digital circuits_     - didn't understand how it related to actual computers -   2003: Took an awful course on computer architecture     - deathly afraid of systems courses -   2005: ðŸ˜± assigned to teach _computer organization and assembly language programming_ in grad school     - ended up teaching it 8 semesters in a row    - 2007: ðŸ˜± took a qualifying exam on computer architecture     - read the entire textbook _and_ the sequel -   2009: got Ph.D.      - this stuff was an important part of my research     ![optical scalar multiplication](/Fall2025/CS130/assets/images/optical-scalar-mult.png) -   2022-2025: Teaching this course after 13 year break    # Course Logistics     ## I'm probably going to be cancelling class for one day very soon  * My wife and I are expecting a baby due very soon ðŸ˜ƒ * Nobody knows exactly *when*  * I will **try my best** to send out an announcement about any cancellations, so watch your email      - worst case scenario: if I don't show up after about 10 minutes, you can assume that's what's going on     ## Course Website   [https://ericmanley.github.io/Fall2025/CS130](https://ericmanley.github.io/Fall2025/CS130/)     #### What to do before coming to the next class    1. Read the [syllabus](https://ericmanley.github.io/Fall2025/CS130/syllabus) 2. From the [resources](https://ericmanley.github.io/Fall2025/CS130/resources) page  - If you don't have a JAVA SDK installed, install a Java SDK     - CS67 students - you can probably use the same one for both classes  - Download and run MARS - the MIPS simulator we'll be using     ## Warm up exercises  Get in groups discuss and write down your ideas  1. Rewrite the following code with one arithmetic operator (+, -, etc.) per line. You can add new variables if you need to. ```python pay = (salary + bonus) - (health_premium + taxes) ```  2. Rewrite lines of this form ```python a = b + c ``` like this ``` add a, b, c ```    ## Discussion Questions  1. What is the difference between computer _memory_ and the computer _disk_? 2. When using Excel spreadsheets, what causes something to be in memory? What causes something to be on the disk? 3. When writing a Python program, what causes something to be in memory? What causes something to be on the disk?    ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-08-25-introduction-to-computer-organization/",
        "teaser": null
      },{
        "title": "Mips Assembly Language copy",
        "excerpt":"## Introduction to # MIPS ---   CS 130 // 2025-08-27    # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. **Assembly language programming** 2. Digital logic 3. Processor architecture 4. The C Programming Language    # Assembly Languages     ## Assembly Languages - Every CPU architecture implements an **instruction set** which are the operations it natively supports -   The most common CPU architectures are:     + x86 (Intel/AMD)     +   ARM (Mobile phones, tablets, Apple's M1 chip, ...)  -   Instructions are extremely simple like ``` add a, b, c ```    ## Revisiting the Exercise from last time  A complicated line of high-level code like this ```python pay = (salary + bonus) - (health_premium + taxes) ```  Gets translated by the *compiler* into assembly code like ```bash add basepay, salary, bonus add deductions, health_premium, taxes sub pay, basepay, deductions ```      ## RISC vs. CISC - CPU architectures are usually categorized as either \"RISC\" or \"CISC\" -   RISC (Reduced Instruction Set Computing)     + Simplified instructions which \"do less\"     + ...but each instruction is highly optimized    ## RISC vs. CISC - CISC (Complicated Instruction Set Computing)     + Larger instruction set each of which \"does more\"     + Optimized so that a program can be implemented with few instructions---even though those instructions may take longer to execute    # MIPS     ## MIPS Architecture - In this course, we will be learning the MIPS instruction set     + \"Microprocessor without Interlocked Pipelined Stages\" - MIPS is a RISC processor with a minimalistic number of instructions - Is very similar to ARM     ## Discussion Question    - what exactly are `salary` or `taxes`  in this example?    ```python pay = (salary + bonus) - (health_premium + taxes) ```     ## Pointers  - In assembly programs, labels like `salary` or `taxes` are *pointers*  -   **pointer**: a stand-in for a _memory address_  -   Even this is too complicated for RISC ```bash add basepay, salary, bonus ```  -   You might first have to grab the data at the address indicated by the pointer _before_ you can do any operations on it.    ## Grabbing data from memory  - When we grab data from memory, where do we put it?  -   **Registers**: a holding place for data right inside the CPU   - data has to be in a register before you can perform operations    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)    ## MIPS Architecture - Has 32 registers, each of which are 32-bits -   Why not include more registers?     +   Cost; registers are more expensive than RAM     +   Performance; more registers means slower clock     +   Instruction size; more registers means each instruction needs more bits to identify registers     #### A MIPS program in MARS  ![Processor component diagram](/Fall2025/CS130/assets/images/first_program.png)     #### Things to notice in MARS  - Registers have names like `$t0`, `$s2`, etc. - You can refer to a register by its name or number.    - `$t0` is also `$8` - MARS can be wonky   - MARS didn't play nice with OneDrive for me - you may need to create a folder for your `.asm` files in your home directory - `lw` means _load word_   - a **word** is a 32 bit value  ```mips #loads a value from memory location a into register $t0 lw $t0, a   ```        #### Exploration Exercise  1. Write the above program in MARS 2. What values are stored in each of the registers initially? 3. Find and press the **Assemble** button 4. What memory addresses did your *program* get stored in? 5. What memory addresses did your *data* get stored in? 6. Find and press the **Run** button 7. What values ended up in `$t0`, `$t1`, and `$t2`? Is that what you expected?    8. Change `a`'s initial value to 9 and rerun. What is in `$t2` now? What do you think is going on here? 9. Add the following to your data section ```mips result: 0 ``` 10. Add the following to the end of your text section ```mips sw $t2, result ``` 11. Rerun. Look in memory - is there a new value there? 12. What do you think `sw` means? 13. Try the **Run one step at a time** button and step through the program slowly. Watch the values change in the registers.     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-08-27-mips-assembly-language%20copy/",
        "teaser": null
      },{
        "title": "Registers Instructions Syscalls",
        "excerpt":"# MIPS Registers, Instructions, and System Calls ---   CS 130 // 2025-09-03    #### The MIPS program we wrote last time  ![first MIPS program](/Fall2025/CS130/assets/images/first_program.png)     ## Review Discussion  * What is the difference between `.data` and `.text`? * What are `a` and `b`?  * What are `$t0`, `$t1`, and `$t2`?  * What does `lw` stand for and what does that mean?  * What does this program do when we run it?    ## MIPS Registers - Has 32 registers, each of which are 32-bits - Data must be in registers before you can do operations on them - You can **load** data from memory into a register with certain commands - You can take data in a register and **store** it in memory with certain commands    ### Exploration Exercise  ```mips # This is my first MIPS program  .data  a: 2 b: 3  .text   lw $t0, a lw $t1, b add $t2, $t0, $t1 ```  * We calculated `a+b` and the result is in register `$t2`.  * Try seeing if you can **store** this result to an actual variable in *memory*.    #### MARS Demo  * We need to be able to do the following in MARS - take notes if needed!   - Find the value stored in any given register   - Find where the values are stored in *memory*   - Find the *address* in memory where an instruction is stored   - Find the *address* in memory where variables are stored   What is a memory *address* again?     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-03-registers-instructions-syscalls/",
        "teaser": null
      },{
        "title": "Binary Branching",
        "excerpt":"# Binary Numbers and Branching  ---   CS 130 // 2025-09-08    # Announcements      ## Tutoring Lab is Open   - Cowles Library 201  - Sundays - Wednesdays 6-9pm  - Please be understanding if they're not always able to help with CS 130       # Review     #### Assignment 1 due today  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes in Figure B.9.1 of the textbook    ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output a string  - a 4 in `$v0` means *print a string*  - **address** of the string should be in `$a0` - `la` means *load address*    - contrast with `lw` - use when you want the data *at the address* not the address itself, so use `lw` if you want to print an int  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### User Input  - a 5 in `$v0` means *read an integer*  - whatever the user types gets put into `$v0` during the syscall  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```     # Logical Operations     ## Boolean values - Suppose I create a `bool` variable in Python:     ```py     b = True     ``` -   How many bits of memory were just allocated?     +   An entire word!     +   `b` is a **memory address** that \"points to\" `True`    ## Logical operator investigation     Before executing: guess what you think `$t0`-`$t5` will be   Execute it: were you right?  Is this how `and` and `or` behave in Python?    ```mips    .text     li $s0, 0    li $s1, 1    li $s2, 2    li $s3, 3        and $t0, $s0, $s1    or $t1, $s0, $s1    andi $t2, $s1, 1    ori $t3, $s1, 0        or $t4, $s1, $s2    and $t5, $s2, $s3 ```       # Binary Numbers     # CS Jokes  ![Only 10 types of people shirt](/Fall2025/CS130/assets/images/shirt10typesOfPeople.jpg)   Source: https://www.amazon.com/Types-People-understand-Binary-T-Shirt/dp/B07PSPLSC9    ## Let's talk about how counting works  ![Odometer rollover](/Fall2025/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits?     ## Counting in Binary - CPUs compute in **binary** using the contrast of low/high voltages to mean 0 and 1 - the two _binary digits_ or **bits** - So how do we encode **numbers** in binary?     ## Base 10 (AKA Decimal)  - When we write 437 we usually mean base 10 - the number system with 10 digits  - Can also write it as $437_\\text{ten}$   - $437_\\text{ten}$ means   `$$(4\\cdot 100)+(3\\cdot 10)+(7\\cdot 1)$$`  or  `$$(4\\cdot 10^2)+(3\\cdot 10^1)+(7\\cdot 10^0)$$`    ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`     ### Demo: Let's convert numbers to different bases   - $110110101_\\text{two}$  - $437_\\text{ten}$    ### Exercise: Practice with Binary - Convert the following number into decimal:     + $1011010_\\text{two}$ - Convert the following decimal number into binary:     + $277_\\text{ten}$      ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0000 0      1 0001 1       2 00102      3 0011 3      4 01004      5 01015      6 01106      7 01117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 0001 000010      17 0001 000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```   ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-08-binary-branching/",
        "teaser": null
      },{
        "title": "Branching",
        "excerpt":"# Branching  ---   CS 130 // 2025-09-10      # Hexadecimal         ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary - Used as *shorthand* for binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0000 0      1 0001 1       2 00102      3 0011 3      4 01004      5 01015      6 01106      7 01117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 0001 000010      17 0001 000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```     ## Set on Less Than investigation     Before executing: guess what you think `$t0`-`$t6` will be  Execute it: were you right?  What do `sle` and `sgt` mean? What do they get translated into by the assemler?    ```mips .text   li $s1, 2 li $s2, 2 li $s3, 3  #slt: \"set on less than\" slt $t0, $s2, $s3 slt $t1, $s1, $s2 slt $t2, $s3, $s2 slti $t3, $s3, 10  #psuedoinstructions sle $t4, $s1, $s3 sle $t5, $s1, $s2 sgt $t6, $s3, $s2 ```       ## Exercise  - Translate the following Python program into MIPS - This is the same as your previous exercise, except with `i     ## Assignment  - [Assignment 2](../../assignments/assignment-2/)   - Translate a Python program that has both an if statement and a loop ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-10-branching/",
        "teaser": null
      },{
        "title": "Arrays",
        "excerpt":"# Arrays, Negative Numbers  ---  CS 130 // 2025-09-15     # Review      ## Compiling a `while` Statement  ```python i = 1 while i != 10:      print(i)    i += 1 ```  ---  ```mips .text \tli $s0, 1 \tli $t0, 10 \t start_loop: \tbeq $s0, $t0, done  \tli $v0, 1 #print integer - no newline after! \tadd $a0, $s0, $zero #copy $s0 into $a0 \tsyscall  \taddi $s0, $s0, 1 \tb start_loop  done: ```      ## Exercise  - Translate this into MIPS - Hint: can you use `slt` here?  ```python sum = 0 i = 0  while i     ## Assignment  - [Assignment 2](../../assignments/assignment-2/)   - Translate a Python program that has both an if statement and a loop       # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2025/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data  my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"   .text      la $s0, my_array #load the base address of the array     li $t0, 0 #loop counter  loop:      slti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array    # Review     ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`   ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-15-arrays/",
        "teaser": null
      },{
        "title": "Procedures",
        "excerpt":"# Procedures  ---  CS 130 // 2025-09-17      # Procedures     ### Compile a Simple Leaf Procedure  ```python def func(x,y):     return x + y ```  ---  ```mips func: add $v0, $a0, $a1       jr  $ra ```  * the first argument to the procedure is in `$a0` * the second argument to the procedure is in `$a1` * the return value of the procedure goes in `$v0` * `jr`: jump to the instruction whose address is in register `$ra`       ```mips func: add $v0, $a0, $a1       jr  $ra ```  When you call this function, you must * put the first argument in `$a0` * put the second argument in `$a1` * put the **return address** in `$ra` * jump to the function    ### Calling Our Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure      ### Nested Procedure Calls  ```python def main():     func(1, func(2, func(3, 4))) ```  ---  ```mips main:     li  $a0, 3     li  $a1, 4     jal func      li   $a0, 2     move $a1, $v0     jal  func      li   $a0, 1     move $a1, $v0     jal  func ``` **remember:** `$v0` is where we find the returned value      ## Calling a Procedure  1. Put parameters in appropriate registers   + `$a0`, `$a1`, `$a2`, `$a3` 2. Transfer control to the procedure: *jump and link*   + `jal ProcedureLabel`     - puts the current instruction's address into `$ra` 3. Perform task 4. Place result in a location the callee can find   + `$v0`, `$v1` 5. Return control to the caller: *jump to addr. in register*   + `jr $ra`     ## Exercise - Convert the following Python code into MIPS - Make sure to create two functions     - make sure the print happens in `main`, not `double_it`  ```python def double_it(e):     return e + e  def main():     print( double_it(21) ) ```     ## Non-Leaf Procedures - Life would be easy if all procedures were \"leaves\" - In reality, a procedure might call another procedure which may call another procedure ... \t- could even be *recursive* -   We need a way to preserve the state of each partially completed call so that they all return properly     # Stack     ## Stack - MIPS provides a register `$sp` that stores a memory address -   Addresses **above** `$sp` is memory that is already being used by other parts of the program -   Addresses **below** `$sp` is free memory    ## Stack - The **called** procedure is responsible for restoring these registers before returning     * any saved registers `$s0`, ..., `$s7`     * `$ra` the return address register     * the stack pointer `$sp` register  -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call     * e.g., if you use `$t0`, `$a0`, or `$v0` the other function might change them!     ## Memory Structure ![MIPS memory structure](/Fall2025/CS130/assets/images/COD/mips-memory.png)    ## Stack Frames ![Procedure frame](/Fall2025/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following Python code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: double_it  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-17-procedures/",
        "teaser": null
      },{
        "title": "Non Leaf Procedures Negative Numbers",
        "excerpt":"## Exam Information, Non-Leaf Procedures, Negative Binary Numbers  ---  CS 130 // 2025-09-22    # Exam 1     ## Exam Info   * In class Monday 9/29 * If you need accomodations, make arrangements with me before we meet again on *Wednesday* * **Material:** Everything we've covered, including today and the next class * **Primary resource:** In-class slides and exercises * Worth about 10% of your overall grade for the course * **Kinds of questions:** short  MIPS coding, short answer, multiple choice    ### What am I allowed to use during the exam?  - A writing utensil - One 8.5\" x 11\" sheet of paper with your hand-written notes on it     * you can write on both sides      * you can write really small (but you probably don't need to)     * must be prepared by you      * nothing printed or photo-copied     * you will turn it in  - Nothing else - no books, laptops, phones, ear buds, etc.    ### How should I study  * Review slides, use textbook if needed  * Practice exercises from class, especially ones you were fuzzy on the first time around * Prepare your note sheet     * Prioritize and organize the knowledge you need to answer questions * Practice using the Review Exercises for Exam 1 item on Blackboard     * Contains actual problems I've used in exams in the past      * Probably longer than the actual exam will be     * May not be quite the same distribution of questions     # Review      ## Calling a Procedure  1. Put parameters in appropriate registers   + `$a0`, `$a1`, `$a2`, `$a3` 2. Transfer control to the procedure: *jump and link*   + `jal ProcedureLabel`     - puts the current instruction's address into `$ra` 3. Perform task 4. Place result in a location the callee can find   + `$v0`, `$v1` 5. Return control to the caller: *jump to addr. in register*   + `jr $ra`     ## Stack - The **called** procedure is responsible for restoring these registers before returning     * any saved registers `$s0`, ..., `$s7`     * `$ra` the return address register     * the stack pointer `$sp` register  -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call     * e.g., if you use `$t0`, `$a0`, or `$v0` the other function might change them!      ## Stack Frames ![Procedure frame](/Fall2025/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following Python code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: double_it  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.    # Negative Numbers     ## Negative Numbers in Binary - We usually represent negative numbers by including a \"minus sign\" at the beginning of a number: $-437$ -   However, when representing numbers for logic circuits, we can **ONLY** use $0$s and $1$s. -   So what do we do?    ## Idea 1: Using a Sign Bit - We could treat the first bit of a number as the \"sign\" bit where $0$ means positive and $1$ means negative     + $10010$ is the same as $-0010$     + $01010$ is the same as $+1010$ -   Drawbacks     + Multiple representations for $0$     +   Addition/subtraction is not as convenient      ## Idea 2: Wrap Around  ![Odometer rollover](/Fall2025/CS130/assets/images/Odometer_rollover.jpg)   - Numbers \"wrap around\" from the **largest** number $999999$ to the **smallest** $000000$ -   We can do the same thing in binary!     +   If you add one to the largest number, it \"wraps around\" to the smallest negative number          # Two's Complement     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$        ## Two's Complement - Most processors are 32-bit or 64-bit, which means values sent to the processor are encoded in 32 or 64 bits, respectively -   In this class, we are using the MIPS 32-bit architecture -   Another way to think about two's complement is:      $1000\\\\;1001\\\\;1100\\\\;1010\\\\;0110\\\\;0110\\\\;0001\\\\;1110$      $(x_{31}\\cdot -2^{31}) + (x_{30}\\cdot 2^{30}) + \\cdots + (x_{1}\\cdot 2^{1}) + (x_{0}\\cdot 2^{0})$    ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$     ## Demo: Adding two binary numbers  * Let's use some 8-bit binary numbers         0010 0011       0001 1000     + 1111 0100     - 0011 0110     ------------    ------------     ## Exercise  * Using 8-bit binary numbers, show how to compute      - 68 - 55     - 20 + 40     - 30 - 127     - -10 + -3      ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-22-non-leaf-procedures-negative-numbers/",
        "teaser": null
      },{
        "title": "Machine Code",
        "excerpt":"# MIPS Machine Code  ---  CS 130 // 2025-09-24    # Review     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$     ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$    ## Demo: Adding two binary numbers  * Let's use some 8-bit binary numbers         0010 0011       0001 1000     + 1111 0100     - 0011 0110     ------------    ------------     ## Exercise  * Using 8-bit binary numbers, show how to compute      - 68 - 55     - 20 + 40     - 30 - 127     - -10 + -3         # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2025/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2025/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2025/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## Exercise  - Use Mars to figure out how each of the following is represented in bits (convert from hex!). ```mips add $t2, $t1, $t0 sub $t2, $t1, $t0 addi $t0, $t0, 3 ``` - What are the opcodes for `add`, `sub`, and `addi`?     ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$    # Shift Instructions     ## Shifting investigation     Execute it: what do `sll` and `srl` do?  What happens if you shift an odd number?  Are these R-Type or I-Type instructions?    ```mips .text   li $s0, 16  #shift left logical sll $t0, $s0, 1 sll $t1, $s0, 2  #shift right logical srl $t2, $s0, 2 ```  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-24-machine-code/",
        "teaser": null
      },{
        "title": "Logic Gates And Truth Tables",
        "excerpt":"## Logic Gates and Truth Tables  ---  CS 130 // 2025-10-01     ## Vermeer Digital Bulldogs  https://www.drake.edu/cs/internships/vermeerdigitalbulldogs/  Deadline is October 15th    ### Preparing for part 2 of the course  We will soon be using a digital logic simulator called Logisim-Evolution   * [Information here](https://github.com/logisim-evolution/logisim-evolution) * [Download here](https://github.com/logisim-evolution/logisim-evolution/releases/tag/v3.7.2) - make sure to get v3.7.2   - **jar** file: should work for anyone (similar to MARS)   - **msi** file: installer for Windows (you probably want x86 version)   - **dmg** file: installer for Mac (may or may not work for M1/M2/M3 Macs)     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. **Digital logic** 3. Processor architecture 4. The C Programming Language    ## Basic CPU Operations - Recall that most operations operate on one or more 32-bit registers     +   `add $s0,` `$s1`, `$s2` takes two 32-bit numbers, adds them up, and produces a new 32-bit number -   How can we build a machine that takes 0s and 1s as input and produces 0s and 1s as output?    # Digital Logic   NOTE: Discuss how hard electrical engineering is and why it is so useful to focus on the simplicity of digital logic    ## Transistors - CPU instructions are implemented with nanoscale switches called **transistors**     ![Light bulb](https://makercise.com/wp-content/uploads/2015/11/vlcsnap-2015-11-17-20h50m57s882.png.jpg)       You can think of a transistor as a \"switch\" with states \"on\" and \"off\"         ## Digital Logic - Learning about electricity, capacitors, resistors, is beyond the scope of this course -   For now, it is useful to abstract away the details of electrical engineering -   We will think about circuits in terms of 0s and 1s going through the wires of a circuit    ## Input/Output as Voltages    - The 0s and 1s of our circuits will be \"low\" and \"high\" voltages across a wire, similar to a light bulb being \"on\" and \"off\"     ![Bits as light bulbs](https://miro.medium.com/max/2400/1*Um-qKrB2QLxRU0C8CkCCeg.png)        ## Logic Gates - A **logic gate** is an elementary circuit that takes one or more bits as input and produces one or more bits as output -   Many of these logic gates can be constructed with one or two transistors    ## AND Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       0                 1       0       0                 1       1       1           ![AND Gate](/Fall2025/CS130/assets/images/gates/and.png)    ## OR Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       1            ![OR Gate](/Fall2025/CS130/assets/images/gates/or.png)      ## NOT Gate                 Input       Output                 0       1                 1       0           ![NOT Gate](/Fall2025/CS130/assets/images/gates/not.png)      ## NAND Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       1                 1       0       1                 1       1       0           ![NAND Gate](/Fall2025/CS130/assets/images/gates/nand.png)     ## NOR Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       0                 1       0       0                 1       1       0           ![NOR Gate](/Fall2025/CS130/assets/images/gates/nor.png)     ## XOR Gate                  Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       0           ![XOR Gate](/Fall2025/CS130/assets/images/gates/xor.png)  (exclusive OR)    ### Demo: What is the truth table for the following circuit?  ---     ![Simple circuit](/Fall2025/CS130/assets/images/gates/simple-circuit.png)                    A       B       C       D                 0       0       0                         0       0       1                         0       1       0                         0       1       1                         1       0       0                         1       0       1                         1       1       0                         1       1       1                         #### Exercise   1. Fill out the truth table 2. Describe what the circuit does using words      ![Simple circuit](/Fall2025/CS130/assets/images/gates/xorcise.png)                    A       B       C                 0       0                         0       1                         1       0                         1       1                       *NB:* a filled dot where wires cross means that the wire splits. If no dot appears, it means one wire is routed over the top of the other.    ### Symbolically describing a circuit         ![Simple circuit](/Fall2025/CS130/assets/images/gates/simple-circuit.png)           $$D = \\overline{(A\\cdot B)} + (B \\cdot C)$$      - $\\overline{A}$ \"not $A$\" - $\\cdot$ \"and\" - $+$ \"or\"    ### Exercise  Symbolically describe the circuit  ![Simple circuit](/Fall2025/CS130/assets/images/gates/xorcise.png)    ### Exercise  1. Draw a circuit representing the logic symbols 2. Write the truth table for the circuit  $$ C = (A \\cdot \\overline{S}) + (B \\cdot S) $$    ### Challenge Exercise       Can you come up with a circuit that has this truth table? - A, B, and C are inputs - E is an output  Verbally describe what this circuit does.   Write the logic symbols representing this circuit.                    A       B       C       E                 0       0       0       0                 0       0       1       1                 0       1       0       1                 0       1       1       0                 1       0       0       1                 1       0       1       0                 1       1       0       0                 1       1       1       1              ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-01-logic-gates-and-truth-tables/",
        "teaser": null
      },{
        "title": "Combinational Logic",
        "excerpt":"# Combinational Logic  ---  CS 130 // 2025-10-06    # Digital Logic Review            ## Boolean Algebra - We can represent logic gate computations as using **Boolean algebra** -   $\\overline{A}\\cdot B+A\\cdot C$ means the same thing as:     + `((not A) and B) or (A and C)`    ## Universal Gates - The **NAND** gate and the **NOR** gate are \"universal\" and can be used to construct every other gate - Using only **NAND** gates, construct circuits that are equivalent to NOT, AND, and OR gates  ![NOT from NAND](/Fall2025/CS130/assets/images/NOT_from_NAND.png) ![AND from NAND](/Fall2025/CS130/assets/images/AND_from_NAND.png) ![OR from NAND](/Fall2025/CS130/assets/images/OR_from_NAND.png)    ### Multiplexor From Last Time        $$ C = (A \\cdot S) + (B \\cdot \\overline{S}) $$  ![Multiplexor Circuit Diagram](/Fall2025/CS130/assets/images/multiplexor_diagram.png)                     A       B       S       C                 0       0       0       0                 0       0       1       0                 0       1       0       1                 0       1       1       0                 1       0       0       0                 1       0       1       1                 1       1       0       1                 1       1       1       1                 #### Demo: Designing and Testing Circuits with Logisim  [Installing Logisim](../../resources/installing-logisim/)  ![Multiplexor Circuit Diagram](/Fall2025/CS130/assets/images/logisim_multiplexor.png)     # Combinational Logic     ## Combinational Logic - **Combinational** logic circuits don't have memory     +   Output depends on only the input     +   Can be completely specified by a truth table -   **Sequential** logic circuits do have memory     +   Output depends on both the input and current state of memory    ## Sum of Products Form - All combinational circuits can be converted to a **sum of products** form that makes them especially easy to implement with gates  ---     -   Need to identify the 1s in the output -   Construct a product term such as $\\overline{A}\\cdot\\overline{B}\\cdot C$ for each 1 in output -   \"Sum\" them together             A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ### Example       $\\overline{A}\\cdot\\overline{B}\\cdot C$  + $\\overline{A}\\cdot B\\cdot \\overline{C}$   +  $A \\cdot \\overline{B}\\cdot \\overline{C}$   +  $A \\cdot B \\cdot C$                 A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ## Exercise: Sum of Products                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1           - Write-out the sum-of-products for this truth table    + Inputs are A, B, C.     + Outputs are Y1, Y0   - Draw the circuit by hand   - Draw the circuit in Logisim    + Manually test some inputs   - Create a run test vector     *NB:* circuits built from the sum-of-products have two stages - ANDs then ORs   - this is called a **programmable logic array** or PLA        ## Assignment  - [Assignment 4](../../assignments/assignment-4/)   - Given a truth table, design a circuit   - Use sum-of-products   - implement it in Logisim   - test it with a test vector   - submit screenshot      ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-06-combinational-logic/",
        "teaser": null
      },{
        "title": "Constructing Adder And Alu",
        "excerpt":"## Constructing an Adder and an ALU  ---  CS 130 // 2025-10-08     # One-bit Adder     #### Full Adder: Circuit that adds three bits                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1                   ![Full Adder](../../assets/images/combinational_FA.png)             # Four-bit Adder     ## Demo: constructing a 4-bit adder from 1-bit full adders  ![4 Bit Adder](../../assets/images/adder4bits.png)  [Adder test vector](../../assets/adder4bit_test_vector.txt)     # ALU     ## The ALU - What does ALU stand for?     + Arithmetic Logic Unit -   What does an ALU do?     + Does all the logical and arithmetic operations of the CPU    ## Basic ALU - The simplest ALU conceivable is one that only operates on two 1-bit inputs and can perform only two operations: **AND** and **OR**     ```py     def basic_alu(a, b, op):         if op == \"0\":             return (a and b)         else:             return (a or b)     ``` -   Let's implement this in Logisim!    ### Exercise: Enhance the Basic ALU 1. make it work on 4-bit values 2. add operations for XOR and NOT  - you will need a bigger multiplexor  - NOT only works on **A** - ignore **B** 3. Can you include your 4-bit adder?     # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 1  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-08-constructing-adder-and-alu/",
        "teaser": null
      },{
        "title": "Sequential Logic",
        "excerpt":"# Sequential Logic  ---  CS 130 // 2025-10-15    # Announcement     ## Announcement  Exams 2 and 3 have each been moved a day earlier  * Exam 2: Monday, October 27th * Exam 3: Wednesday, November 19th  Exam review questions have been posted on Blackboard.    # Review: Adder and ALU Start       ## 4-Bit Adder and a Start to an ALU     ![4 Bit Adder](../../assets/images/adder_subtractor_4_bits.png)      ![4 Bit Adder](../../assets/images/alu_4_bits.png)        # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 0    ## Exercise  - Work on getting subtraction and `slt` working in your 4-bit ALU    ## Assignment  - [Assignment 5](../../assignments/assignment-5)   - make a 32-bit ALU   - `add`, `sub`, `and`, `or`, `not`, `xor`, `slt`, and anything else you want   - you can use Logisim's built-in components   - try not to duplicate circuitry for `add`, `sub`, and `slt`.   - submit screenshots of circuits *and* test vector (with comments)    # Sequential Logic     ## Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## S-R Latch     - A \"set reset\" latch is implemented with      - Let's fill in the truth table together              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 01      0 0 10      1 0 01      1 0 10      0 1 01      0 1 10           ## D Latch     - A \"data\" latch is implemented with      - Let's fill in the truth table together               $C$$D$$Q_\\text{next}$      0 0       0 1       1 0       1 1            ## Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)    ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png) ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-15-sequential-logic/",
        "teaser": null
      },{
        "title": "Registers Memory",
        "excerpt":"# Registers and Memory  ---  CS 130 // 2025-10-20    # Review     ## Sequential Logic - **Sequential** logic circuits have memory     +   Output depends on both the input and current state of memory     +   Behavior can change **over time**    ### Sequential Logic Components - **Clock**: a signal that oscillates between 0 and 1 -   **Latch**: 1-bit memory element that is updated when the clock is 1 -   **Flip Flop**: 1-bit memory element that is updated when the clock transitions from a 1 to a 0    ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)    ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png)    ## Exercise: Build a register File in Logisim     - 32 bits - at least 4 registers   ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)      ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)   ![register file glimpse](../../assets/images/register_file_glimpse.png)          # ROM      ## ROM: Read-Only Memory   - Intended only to be read from (though it may be possible to change it in some circumstances) - **Non-volatile**: keeps its value without power - Game Cartidges, CD-ROM, DVD - Firmware for PCs and other devices   + contains boot-up instructions  ![CD ROM](../../assets/images/CD-ROM.png)  ![game cartridge](../../assets/images/gamecartridge.jpg)     # RAM     ## RAM: Random Access Memory - It takes the same amount of time to access data regardless of where it is   ![RAM modules](../../assets/images/ram.jpg)      ## Static Random Access Memory - Memory where data is stored *statically* with flip-flops - Faster than DRAM but less dense (lower capacity) and more expensive per bit - As long as it has power, SRAM will keep its value - Usually used for cache memory    ## Dynamic Random Access Memory - DRAM is the most dense RAM     * Implemented with capacitors instead of latches - stores energy in an electrical field - Must be occasionally \"refreshed\" because the capacitors slowly lose their stored values     * This is why it is called \"dynamic\" - Usually used for large capacity RAM  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-20-registers-memory/",
        "teaser": null
      },{
        "title": "Instruction_memory_decode",
        "excerpt":"# Instruction Memory and Decode  ---  CS 130 // 2025-10-22     ## Instruction Memory on the CPU  ![Instruction Fetch](/Fall2025/CS130/assets/images/COD/instruction_fetch.png)    ## Demo: Make it in Logisim       Use a ROM to simulate instruction memory  - 16 bit address (should be 32 for MIPS, but that is too big for Logisim) - Quad output - so we can read four bytes at a time - lowest-address byte is shown first in Logisim memory contents      ![MIPS program in Logisim](../../assets/images/mips-for-logisim-rom.png)   ![MIPS program in MARS](../../assets/images/mips-for-logisim-mars.png)          ## Exercise    - Create a Program Counter Register which iterates through the instructions in memory   ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)    ## Exercise   - You can set your splitter to have custom fan-out ranges - Make a separate pin for each instruction field (opcode, rs, rt, etc.)       ![Custom Ranges for Splitter](../../assets/images/custom-splitter.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)        ## What's next?   * Use these circuits (or build your own)     - [Logisim Register File and ALU](https://ericmanley.github.io/Fall2025/CS130/assets/RegisterFileAndALU.circ) * Think about how you can hook up your decoded instruction to the register file and ALU so that it does the right thing for the instructions  ``` addi $9, $0, 7 addi $10, $0, 8 add $8, $9, $10 ```","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-22-instruction_memory_decode/",
        "teaser": null
      }]
