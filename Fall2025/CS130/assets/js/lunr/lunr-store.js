var store = [{
        "title": "Lecture: Computer Organization",
        "excerpt":"# Computer Organization #### and Assembly Language Programming  ---  CS 130 // 2025-08-25    # Welcome! Instructor: Eric Manley  ---     **Office:** Collier-Scripps 327 **Email:**  **Phone:** (515) 271-2177     **Office Hours:** Schedule in [Calendly](https://calendly.com/eric-manley/) the day before or drop inMW 9:45-11:30am (tentative)         # Course Overview     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    So... what is a processor?     ![Photo of the inside of a laptop](/Fall2025/CS130/assets/images/COD/inside-laptop.png)    ![Components of a processor](/Fall2025/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)     ## Major Aspects of the Course 1. Assembly language programming 2.   Digital logic 3.   Processor architecture 4.  The C Programming Language     #### Why should I learn this stuff?  Let's start with three good reasons    #### Reason 1: Sometimes you really need to understand the system to solve your problems  There are issues related to performance and security that must be solved at *lower-levels of abstraction*     #### Example: Shazam - the transaction processing company  ![Transaction processing network](/Fall2025/CS130/assets/images/transaction-processing-network.png) - They hire developers in Des Moines - Need to process transactions fast  - If the Java garbage collector kicks in, they're in trouble     #### Reason 2: In the age of AI, being good at programming isn't good enough   [https://livebench.ai/](https://livebench.ai/)     Developers who will set themselves apart understand technological foundations, can design at higher levels, and can evaluated and refine what AI produces    #### Reason 3: How does magic *really* work in our world?        ![Door to Moria](/Fall2025/CS130/assets/images/moria-door.webp)   ![Mistborn novel cover](/Fall2025/CS130/assets/images/mistborn-book.jpg)      ![Dungeons and Dragons spells](/Fall2025/CS130/assets/images/phb-spells.jpg)             ### My background with this course  - 1996-2004: C/C++ was my _native_ language -   2001: I took a course in _assembly_ and _digital circuits_     - didn't understand how it related to actual computers -   2003: Took an awful course on computer architecture     - deathly afraid of systems courses -   2005: ðŸ˜± assigned to teach _computer organization and assembly language programming_ in grad school     - ended up teaching it 8 semesters in a row    - 2007: ðŸ˜± took a qualifying exam on computer architecture     - read the entire textbook _and_ the sequel -   2009: got Ph.D.      - this stuff was an important part of my research     ![optical scalar multiplication](/Fall2025/CS130/assets/images/optical-scalar-mult.png) -   2022-2025: Teaching this course after 13 year break    # Course Logistics     ## I'm probably going to be cancelling class for one day very soon  * My wife and I are expecting a baby due very soon ðŸ˜ƒ * Nobody knows exactly *when*  * I will **try my best** to send out an announcement about any cancellations, so watch your email      - worst case scenario: if I don't show up after about 10 minutes, you can assume that's what's going on     ## Course Website   [https://ericmanley.github.io/Fall2025/CS130](https://ericmanley.github.io/Fall2025/CS130/)     #### What to do before coming to the next class    1. Read the [syllabus](https://ericmanley.github.io/Fall2025/CS130/syllabus) 2. From the [resources](https://ericmanley.github.io/Fall2025/CS130/resources) page  - If you don't have a JAVA SDK installed, install a Java SDK     - CS67 students - you can probably use the same one for both classes  - Download and run MARS - the MIPS simulator we'll be using     ## Warm up exercises  Get in groups discuss and write down your ideas  1. Rewrite the following code with one arithmetic operator (+, -, etc.) per line. You can add new variables if you need to. ```python pay = (salary + bonus) - (health_premium + taxes) ```  2. Rewrite lines of this form ```python a = b + c ``` like this ``` add a, b, c ```    ## Discussion Questions  1. What is the difference between computer _memory_ and the computer _disk_? 2. When using Excel spreadsheets, what causes something to be in memory? What causes something to be on the disk? 3. When writing a Python program, what causes something to be in memory? What causes something to be on the disk?    ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-08-25-introduction-to-computer-organization/",
        "teaser": null
      },{
        "title": "Mips Assembly Language copy",
        "excerpt":"## Introduction to # MIPS ---   CS 130 // 2025-08-27    # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. **Assembly language programming** 2. Digital logic 3. Processor architecture 4. The C Programming Language    # Assembly Languages     ## Assembly Languages - Every CPU architecture implements an **instruction set** which are the operations it natively supports -   The most common CPU architectures are:     + x86 (Intel/AMD)     +   ARM (Mobile phones, tablets, Apple's M1 chip, ...)  -   Instructions are extremely simple like ``` add a, b, c ```    ## Revisiting the Exercise from last time  A complicated line of high-level code like this ```python pay = (salary + bonus) - (health_premium + taxes) ```  Gets translated by the *compiler* into assembly code like ```bash add basepay, salary, bonus add deductions, health_premium, taxes sub pay, basepay, deductions ```      ## RISC vs. CISC - CPU architectures are usually categorized as either \"RISC\" or \"CISC\" -   RISC (Reduced Instruction Set Computing)     + Simplified instructions which \"do less\"     + ...but each instruction is highly optimized    ## RISC vs. CISC - CISC (Complicated Instruction Set Computing)     + Larger instruction set each of which \"does more\"     + Optimized so that a program can be implemented with few instructions---even though those instructions may take longer to execute    # MIPS     ## MIPS Architecture - In this course, we will be learning the MIPS instruction set     + \"Microprocessor without Interlocked Pipelined Stages\" - MIPS is a RISC processor with a minimalistic number of instructions - Is very similar to ARM     ## Discussion Question    - what exactly are `salary` or `taxes`  in this example?    ```python pay = (salary + bonus) - (health_premium + taxes) ```     ## Pointers  - In assembly programs, labels like `salary` or `taxes` are *pointers*  -   **pointer**: a stand-in for a _memory address_  -   Even this is too complicated for RISC ```bash add basepay, salary, bonus ```  -   You might first have to grab the data at the address indicated by the pointer _before_ you can do any operations on it.    ## Grabbing data from memory  - When we grab data from memory, where do we put it?  -   **Registers**: a holding place for data right inside the CPU   - data has to be in a register before you can perform operations    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)    ## MIPS Architecture - Has 32 registers, each of which are 32-bits -   Why not include more registers?     +   Cost; registers are more expensive than RAM     +   Performance; more registers means slower clock     +   Instruction size; more registers means each instruction needs more bits to identify registers     #### A MIPS program in MARS  ![Processor component diagram](/Fall2025/CS130/assets/images/first_program.png)     #### Things to notice in MARS  - Registers have names like `$t0`, `$s2`, etc. - You can refer to a register by its name or number.    - `$t0` is also `$8` - MARS can be wonky   - MARS didn't play nice with OneDrive for me - you may need to create a folder for your `.asm` files in your home directory - `lw` means _load word_   - a **word** is a 32 bit value  ```mips #loads a value from memory location a into register $t0 lw $t0, a   ```        #### Exploration Exercise  1. Write the above program in MARS 2. What values are stored in each of the registers initially? 3. Find and press the **Assemble** button 4. What memory addresses did your *program* get stored in? 5. What memory addresses did your *data* get stored in? 6. Find and press the **Run** button 7. What values ended up in `$t0`, `$t1`, and `$t2`? Is that what you expected?    8. Change `a`'s initial value to 9 and rerun. What is in `$t2` now? What do you think is going on here? 9. Add the following to your data section ```mips result: 0 ``` 10. Add the following to the end of your text section ```mips sw $t2, result ``` 11. Rerun. Look in memory - is there a new value there? 12. What do you think `sw` means? 13. Try the **Run one step at a time** button and step through the program slowly. Watch the values change in the registers.     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-08-27-mips-assembly-language%20copy/",
        "teaser": null
      },{
        "title": "Registers Instructions Syscalls",
        "excerpt":"# MIPS Registers, Instructions, and System Calls ---   CS 130 // 2025-09-03    #### The MIPS program we wrote last time  ![first MIPS program](/Fall2025/CS130/assets/images/first_program.png)     ## Review Discussion  * What is the difference between `.data` and `.text`? * What are `a` and `b`?  * What are `$t0`, `$t1`, and `$t2`?  * What does `lw` stand for and what does that mean?  * What does this program do when we run it?    ## MIPS Registers - Has 32 registers, each of which are 32-bits - Data must be in registers before you can do operations on them - You can **load** data from memory into a register with certain commands - You can take data in a register and **store** it in memory with certain commands    ### Exploration Exercise  ```mips # This is my first MIPS program  .data  a: 2 b: 3  .text   lw $t0, a lw $t1, b add $t2, $t0, $t1 ```  * We calculated `a+b` and the result is in register `$t2`.  * Try seeing if you can **store** this result to an actual variable in *memory*.    #### MARS Demo  * We need to be able to do the following in MARS - take notes if needed!   - Find the value stored in any given register   - Find where the values are stored in *memory*   - Find the *address* in memory where an instruction is stored   - Find the *address* in memory where variables are stored   What is a memory *address* again?     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-03-registers-instructions-syscalls/",
        "teaser": null
      },{
        "title": "Binary Branching",
        "excerpt":"# Binary Numbers and Branching  ---   CS 130 // 2025-09-08    # Announcements      ## Tutoring Lab is Open   - Cowles Library 201  - Sundays - Wednesdays 6-9pm  - Please be understanding if they're not always able to help with CS 130       # Review     #### Assignment 1 due today  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes in Figure B.9.1 of the textbook    ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output a string  - a 4 in `$v0` means *print a string*  - **address** of the string should be in `$a0` - `la` means *load address*    - contrast with `lw` - use when you want the data *at the address* not the address itself, so use `lw` if you want to print an int  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### User Input  - a 5 in `$v0` means *read an integer*  - whatever the user types gets put into `$v0` during the syscall  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```     # Logical Operations     ## Boolean values - Suppose I create a `bool` variable in Python:     ```py     b = True     ``` -   How many bits of memory were just allocated?     +   An entire word!     +   `b` is a **memory address** that \"points to\" `True`    ## Logical operator investigation     Before executing: guess what you think `$t0`-`$t5` will be   Execute it: were you right?  Is this how `and` and `or` behave in Python?    ```mips    .text     li $s0, 0    li $s1, 1    li $s2, 2    li $s3, 3        and $t0, $s0, $s1    or $t1, $s0, $s1    andi $t2, $s1, 1    ori $t3, $s1, 0        or $t4, $s1, $s2    and $t5, $s2, $s3 ```       # Binary Numbers     # CS Jokes  ![Only 10 types of people shirt](/Fall2025/CS130/assets/images/shirt10typesOfPeople.jpg)   Source: https://www.amazon.com/Types-People-understand-Binary-T-Shirt/dp/B07PSPLSC9    ## Let's talk about how counting works  ![Odometer rollover](/Fall2025/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits?     ## Counting in Binary - CPUs compute in **binary** using the contrast of low/high voltages to mean 0 and 1 - the two _binary digits_ or **bits** - So how do we encode **numbers** in binary?     ## Base 10 (AKA Decimal)  - When we write 437 we usually mean base 10 - the number system with 10 digits  - Can also write it as $437_\\text{ten}$   - $437_\\text{ten}$ means   `$$(4\\cdot 100)+(3\\cdot 10)+(7\\cdot 1)$$`  or  `$$(4\\cdot 10^2)+(3\\cdot 10^1)+(7\\cdot 10^0)$$`    ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`     ### Demo: Let's convert numbers to different bases   - $110110101_\\text{two}$  - $437_\\text{ten}$    ### Exercise: Practice with Binary - Convert the following number into decimal:     + $1011010_\\text{two}$ - Convert the following decimal number into binary:     + $277_\\text{ten}$      ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0000 0      1 0001 1       2 00102      3 0011 3      4 01004      5 01015      6 01106      7 01117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 0001 000010      17 0001 000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```   ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-08-binary-branching/",
        "teaser": null
      },{
        "title": "Branching",
        "excerpt":"# Branching  ---   CS 130 // 2025-09-10      # Hexadecimal         ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary - Used as *shorthand* for binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0000 0      1 0001 1       2 00102      3 0011 3      4 01004      5 01015      6 01106      7 01117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 0001 000010      17 0001 000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```     ## Set on Less Than investigation     Before executing: guess what you think `$t0`-`$t6` will be  Execute it: were you right?  What do `sle` and `sgt` mean? What do they get translated into by the assemler?    ```mips .text   li $s1, 2 li $s2, 2 li $s3, 3  #slt: \"set on less than\" slt $t0, $s2, $s3 slt $t1, $s1, $s2 slt $t2, $s3, $s2 slti $t3, $s3, 10  #psuedoinstructions sle $t4, $s1, $s3 sle $t5, $s1, $s2 sgt $t6, $s3, $s2 ```       ## Exercise  - Translate the following Python program into MIPS - This is the same as your previous exercise, except with `i     ## Assignment  - [Assignment 2](../../assignments/assignment-2/)   - Translate a Python program that has both an if statement and a loop ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-10-branching/",
        "teaser": null
      },{
        "title": "Arrays",
        "excerpt":"# Arrays, Negative Numbers  ---  CS 130 // 2025-09-15     # Review      ## Compiling a `while` Statement  ```python i = 1 while i != 10:      print(i)    i += 1 ```  ---  ```mips .text \tli $s0, 1 \tli $t0, 10 \t start_loop: \tbeq $s0, $t0, done  \tli $v0, 1 #print integer - no newline after! \tadd $a0, $s0, $zero #copy $s0 into $a0 \tsyscall  \taddi $s0, $s0, 1 \tb start_loop  done: ```      ## Exercise  - Translate this into MIPS - Hint: can you use `slt` here?  ```python sum = 0 i = 0  while i     ## Assignment  - [Assignment 2](../../assignments/assignment-2/)   - Translate a Python program that has both an if statement and a loop       # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2025/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data  my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"   .text      la $s0, my_array #load the base address of the array     li $t0, 0 #loop counter  loop:      slti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array    # Review     ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`   ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-15-arrays/",
        "teaser": null
      },{
        "title": "Procedures",
        "excerpt":"# Procedures  ---  CS 130 // 2025-09-17      # Procedures     ### Compile a Simple Leaf Procedure  ```python def func(x,y):     return x + y ```  ---  ```mips func: add $v0, $a0, $a1       jr  $ra ```  * the first argument to the procedure is in `$a0` * the second argument to the procedure is in `$a1` * the return value of the procedure goes in `$v0` * `jr`: jump to the instruction whose address is in register `$ra`       ```mips func: add $v0, $a0, $a1       jr  $ra ```  When you call this function, you must * put the first argument in `$a0` * put the second argument in `$a1` * put the **return address** in `$ra` * jump to the function    ### Calling Our Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure      ### Nested Procedure Calls  ```python def main():     func(1, func(2, func(3, 4))) ```  ---  ```mips main:     li  $a0, 3     li  $a1, 4     jal func      li   $a0, 2     move $a1, $v0     jal  func      li   $a0, 1     move $a1, $v0     jal  func ``` **remember:** `$v0` is where we find the returned value      ## Calling a Procedure  1. Put parameters in appropriate registers   + `$a0`, `$a1`, `$a2`, `$a3` 2. Transfer control to the procedure: *jump and link*   + `jal ProcedureLabel`     - puts the current instruction's address into `$ra` 3. Perform task 4. Place result in a location the callee can find   + `$v0`, `$v1` 5. Return control to the caller: *jump to addr. in register*   + `jr $ra`     ## Exercise - Convert the following Python code into MIPS - Make sure to create two functions     - make sure the print happens in `main`, not `double_it`  ```python def double_it(e):     return e + e  def main():     print( double_it(21) ) ```     ## Non-Leaf Procedures - Life would be easy if all procedures were \"leaves\" - In reality, a procedure might call another procedure which may call another procedure ... \t- could even be *recursive* -   We need a way to preserve the state of each partially completed call so that they all return properly     # Stack     ## Stack - MIPS provides a register `$sp` that stores a memory address -   Addresses **above** `$sp` is memory that is already being used by other parts of the program -   Addresses **below** `$sp` is free memory    ## Stack - The **called** procedure is responsible for restoring these registers before returning     * any saved registers `$s0`, ..., `$s7`     * `$ra` the return address register     * the stack pointer `$sp` register  -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call     * e.g., if you use `$t0`, `$a0`, or `$v0` the other function might change them!     ## Memory Structure ![MIPS memory structure](/Fall2025/CS130/assets/images/COD/mips-memory.png)    ## Stack Frames ![Procedure frame](/Fall2025/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following Python code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: double_it  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-17-procedures/",
        "teaser": null
      },{
        "title": "Non Leaf Procedures Negative Numbers",
        "excerpt":"## Exam Information, Non-Leaf Procedures, Negative Binary Numbers  ---  CS 130 // 2025-09-22    # Exam 1     ## Exam Info   * In class Monday 9/29 * If you need accomodations, make arrangements with me before we meet again on *Wednesday* * **Material:** Everything we've covered, including today and the next class * **Primary resource:** In-class slides and exercises * Worth about 10% of your overall grade for the course * **Kinds of questions:** short  MIPS coding, short answer, multiple choice    ### What am I allowed to use during the exam?  - A writing utensil - One 8.5\" x 11\" sheet of paper with your hand-written notes on it     * you can write on both sides      * you can write really small (but you probably don't need to)     * must be prepared by you      * nothing printed or photo-copied     * you will turn it in  - Nothing else - no books, laptops, phones, ear buds, etc.    ### How should I study  * Review slides, use textbook if needed  * Practice exercises from class, especially ones you were fuzzy on the first time around * Prepare your note sheet     * Prioritize and organize the knowledge you need to answer questions * Practice using the Review Exercises for Exam 1 item on Blackboard     * Contains actual problems I've used in exams in the past      * Probably longer than the actual exam will be     * May not be quite the same distribution of questions     # Review      ## Calling a Procedure  1. Put parameters in appropriate registers   + `$a0`, `$a1`, `$a2`, `$a3` 2. Transfer control to the procedure: *jump and link*   + `jal ProcedureLabel`     - puts the current instruction's address into `$ra` 3. Perform task 4. Place result in a location the callee can find   + `$v0`, `$v1` 5. Return control to the caller: *jump to addr. in register*   + `jr $ra`     ## Stack - The **called** procedure is responsible for restoring these registers before returning     * any saved registers `$s0`, ..., `$s7`     * `$ra` the return address register     * the stack pointer `$sp` register  -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call     * e.g., if you use `$t0`, `$a0`, or `$v0` the other function might change them!      ## Stack Frames ![Procedure frame](/Fall2025/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following Python code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: double_it  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.    # Negative Numbers     ## Negative Numbers in Binary - We usually represent negative numbers by including a \"minus sign\" at the beginning of a number: $-437$ -   However, when representing numbers for logic circuits, we can **ONLY** use $0$s and $1$s. -   So what do we do?    ## Idea 1: Using a Sign Bit - We could treat the first bit of a number as the \"sign\" bit where $0$ means positive and $1$ means negative     + $10010$ is the same as $-0010$     + $01010$ is the same as $+1010$ -   Drawbacks     + Multiple representations for $0$     +   Addition/subtraction is not as convenient      ## Idea 2: Wrap Around  ![Odometer rollover](/Fall2025/CS130/assets/images/Odometer_rollover.jpg)   - Numbers \"wrap around\" from the **largest** number $999999$ to the **smallest** $000000$ -   We can do the same thing in binary!     +   If you add one to the largest number, it \"wraps around\" to the smallest negative number          # Two's Complement     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$        ## Two's Complement - Most processors are 32-bit or 64-bit, which means values sent to the processor are encoded in 32 or 64 bits, respectively -   In this class, we are using the MIPS 32-bit architecture -   Another way to think about two's complement is:      $1000\\\\;1001\\\\;1100\\\\;1010\\\\;0110\\\\;0110\\\\;0001\\\\;1110$      $(x_{31}\\cdot -2^{31}) + (x_{30}\\cdot 2^{30}) + \\cdots + (x_{1}\\cdot 2^{1}) + (x_{0}\\cdot 2^{0})$    ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$     ## Demo: Adding two binary numbers  * Let's use some 8-bit binary numbers         0010 0011       0001 1000     + 1111 0100     - 0011 0110     ------------    ------------     ## Exercise  * Using 8-bit binary numbers, show how to compute      - 68 - 55     - 20 + 40     - 30 - 127     - -10 + -3      ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-22-non-leaf-procedures-negative-numbers/",
        "teaser": null
      },{
        "title": "Machine Code",
        "excerpt":"# MIPS Machine Code  ---  CS 130 // 2025-09-24    # Review     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$     ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$    ## Demo: Adding two binary numbers  * Let's use some 8-bit binary numbers         0010 0011       0001 1000     + 1111 0100     - 0011 0110     ------------    ------------     ## Exercise  * Using 8-bit binary numbers, show how to compute      - 68 - 55     - 20 + 40     - 30 - 127     - -10 + -3         # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2025/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2025/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2025/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## Exercise  - Use Mars to figure out how each of the following is represented in bits (convert from hex!). ```mips add $t2, $t1, $t0 sub $t2, $t1, $t0 addi $t0, $t0, 3 ``` - What are the opcodes for `add`, `sub`, and `addi`?     ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$    # Shift Instructions     ## Shifting investigation     Execute it: what do `sll` and `srl` do?  What happens if you shift an odd number?  Are these R-Type or I-Type instructions?    ```mips .text   li $s0, 16  #shift left logical sll $t0, $s0, 1 sll $t1, $s0, 2  #shift right logical srl $t2, $s0, 2 ```  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-09-24-machine-code/",
        "teaser": null
      },{
        "title": "Logic Gates And Truth Tables",
        "excerpt":"## Logic Gates and Truth Tables  ---  CS 130 // 2025-10-01     ## Vermeer Digital Bulldogs  https://www.drake.edu/cs/internships/vermeerdigitalbulldogs/  Deadline is October 15th    ### Preparing for part 2 of the course  We will soon be using a digital logic simulator called Logisim-Evolution   * [Information here](https://github.com/logisim-evolution/logisim-evolution) * [Download here](https://github.com/logisim-evolution/logisim-evolution/releases/tag/v3.7.2) - make sure to get v3.7.2   - **jar** file: should work for anyone (similar to MARS)   - **msi** file: installer for Windows (you probably want x86 version)   - **dmg** file: installer for Mac (may or may not work for M1/M2/M3 Macs)     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. **Digital logic** 3. Processor architecture 4. The C Programming Language    ## Basic CPU Operations - Recall that most operations operate on one or more 32-bit registers     +   `add $s0,` `$s1`, `$s2` takes two 32-bit numbers, adds them up, and produces a new 32-bit number -   How can we build a machine that takes 0s and 1s as input and produces 0s and 1s as output?    # Digital Logic   NOTE: Discuss how hard electrical engineering is and why it is so useful to focus on the simplicity of digital logic    ## Transistors - CPU instructions are implemented with nanoscale switches called **transistors**     ![Light bulb](https://makercise.com/wp-content/uploads/2015/11/vlcsnap-2015-11-17-20h50m57s882.png.jpg)       You can think of a transistor as a \"switch\" with states \"on\" and \"off\"         ## Digital Logic - Learning about electricity, capacitors, resistors, is beyond the scope of this course -   For now, it is useful to abstract away the details of electrical engineering -   We will think about circuits in terms of 0s and 1s going through the wires of a circuit    ## Input/Output as Voltages    - The 0s and 1s of our circuits will be \"low\" and \"high\" voltages across a wire, similar to a light bulb being \"on\" and \"off\"     ![Bits as light bulbs](https://miro.medium.com/max/2400/1*Um-qKrB2QLxRU0C8CkCCeg.png)        ## Logic Gates - A **logic gate** is an elementary circuit that takes one or more bits as input and produces one or more bits as output -   Many of these logic gates can be constructed with one or two transistors    ## AND Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       0                 1       0       0                 1       1       1           ![AND Gate](/Fall2025/CS130/assets/images/gates/and.png)    ## OR Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       1            ![OR Gate](/Fall2025/CS130/assets/images/gates/or.png)      ## NOT Gate                 Input       Output                 0       1                 1       0           ![NOT Gate](/Fall2025/CS130/assets/images/gates/not.png)      ## NAND Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       1                 1       0       1                 1       1       0           ![NAND Gate](/Fall2025/CS130/assets/images/gates/nand.png)     ## NOR Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       0                 1       0       0                 1       1       0           ![NOR Gate](/Fall2025/CS130/assets/images/gates/nor.png)     ## XOR Gate                  Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       0           ![XOR Gate](/Fall2025/CS130/assets/images/gates/xor.png)  (exclusive OR)    ### Demo: What is the truth table for the following circuit?  ---     ![Simple circuit](/Fall2025/CS130/assets/images/gates/simple-circuit.png)                    A       B       C       D                 0       0       0                         0       0       1                         0       1       0                         0       1       1                         1       0       0                         1       0       1                         1       1       0                         1       1       1                         #### Exercise   1. Fill out the truth table 2. Describe what the circuit does using words      ![Simple circuit](/Fall2025/CS130/assets/images/gates/xorcise.png)                    A       B       C                 0       0                         0       1                         1       0                         1       1                       *NB:* a filled dot where wires cross means that the wire splits. If no dot appears, it means one wire is routed over the top of the other.    ### Symbolically describing a circuit         ![Simple circuit](/Fall2025/CS130/assets/images/gates/simple-circuit.png)           $$D = \\overline{(A\\cdot B)} + (B \\cdot C)$$      - $\\overline{A}$ \"not $A$\" - $\\cdot$ \"and\" - $+$ \"or\"    ### Exercise  Symbolically describe the circuit  ![Simple circuit](/Fall2025/CS130/assets/images/gates/xorcise.png)    ### Exercise  1. Draw a circuit representing the logic symbols 2. Write the truth table for the circuit  $$ C = (A \\cdot \\overline{S}) + (B \\cdot S) $$    ### Challenge Exercise       Can you come up with a circuit that has this truth table? - A, B, and C are inputs - E is an output  Verbally describe what this circuit does.   Write the logic symbols representing this circuit.                    A       B       C       E                 0       0       0       0                 0       0       1       1                 0       1       0       1                 0       1       1       0                 1       0       0       1                 1       0       1       0                 1       1       0       0                 1       1       1       1              ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-01-logic-gates-and-truth-tables/",
        "teaser": null
      },{
        "title": "Combinational Logic",
        "excerpt":"# Combinational Logic  ---  CS 130 // 2025-10-06    # Digital Logic Review            ## Boolean Algebra - We can represent logic gate computations as using **Boolean algebra** -   $\\overline{A}\\cdot B+A\\cdot C$ means the same thing as:     + `((not A) and B) or (A and C)`    ## Universal Gates - The **NAND** gate and the **NOR** gate are \"universal\" and can be used to construct every other gate - Using only **NAND** gates, construct circuits that are equivalent to NOT, AND, and OR gates  ![NOT from NAND](/Fall2025/CS130/assets/images/NOT_from_NAND.png) ![AND from NAND](/Fall2025/CS130/assets/images/AND_from_NAND.png) ![OR from NAND](/Fall2025/CS130/assets/images/OR_from_NAND.png)    ### Multiplexor From Last Time        $$ C = (A \\cdot S) + (B \\cdot \\overline{S}) $$  ![Multiplexor Circuit Diagram](/Fall2025/CS130/assets/images/multiplexor_diagram.png)                     A       B       S       C                 0       0       0       0                 0       0       1       0                 0       1       0       1                 0       1       1       0                 1       0       0       0                 1       0       1       1                 1       1       0       1                 1       1       1       1                 #### Demo: Designing and Testing Circuits with Logisim  [Installing Logisim](../../resources/installing-logisim/)  ![Multiplexor Circuit Diagram](/Fall2025/CS130/assets/images/logisim_multiplexor.png)     # Combinational Logic     ## Combinational Logic - **Combinational** logic circuits don't have memory     +   Output depends on only the input     +   Can be completely specified by a truth table -   **Sequential** logic circuits do have memory     +   Output depends on both the input and current state of memory    ## Sum of Products Form - All combinational circuits can be converted to a **sum of products** form that makes them especially easy to implement with gates  ---     -   Need to identify the 1s in the output -   Construct a product term such as $\\overline{A}\\cdot\\overline{B}\\cdot C$ for each 1 in output -   \"Sum\" them together             A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ### Example       $\\overline{A}\\cdot\\overline{B}\\cdot C$  + $\\overline{A}\\cdot B\\cdot \\overline{C}$   +  $A \\cdot \\overline{B}\\cdot \\overline{C}$   +  $A \\cdot B \\cdot C$                 A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ## Exercise: Sum of Products                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1           - Write-out the sum-of-products for this truth table    + Inputs are A, B, C.     + Outputs are Y1, Y0   - Draw the circuit by hand   - Draw the circuit in Logisim    + Manually test some inputs   - Create a run test vector     *NB:* circuits built from the sum-of-products have two stages - ANDs then ORs   - this is called a **programmable logic array** or PLA        ## Assignment  - [Assignment 4](../../assignments/assignment-4/)   - Given a truth table, design a circuit   - Use sum-of-products   - implement it in Logisim   - test it with a test vector   - submit screenshot      ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-06-combinational-logic/",
        "teaser": null
      },{
        "title": "Constructing Adder And Alu",
        "excerpt":"## Constructing an Adder and an ALU  ---  CS 130 // 2025-10-08     # One-bit Adder     #### Full Adder: Circuit that adds three bits                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1                   ![Full Adder](../../assets/images/combinational_FA.png)             # Four-bit Adder     ## Demo: constructing a 4-bit adder from 1-bit full adders  ![4 Bit Adder](../../assets/images/adder4bits.png)  [Adder test vector](../../assets/adder4bit_test_vector.txt)     # ALU     ## The ALU - What does ALU stand for?     + Arithmetic Logic Unit -   What does an ALU do?     + Does all the logical and arithmetic operations of the CPU    ## Basic ALU - The simplest ALU conceivable is one that only operates on two 1-bit inputs and can perform only two operations: **AND** and **OR**     ```py     def basic_alu(a, b, op):         if op == \"0\":             return (a and b)         else:             return (a or b)     ``` -   Let's implement this in Logisim!    ### Exercise: Enhance the Basic ALU 1. make it work on 4-bit values 2. add operations for XOR and NOT  - you will need a bigger multiplexor  - NOT only works on **A** - ignore **B** 3. Can you include your 4-bit adder?     # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 1  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-08-constructing-adder-and-alu/",
        "teaser": null
      },{
        "title": "Sequential Logic",
        "excerpt":"# Sequential Logic  ---  CS 130 // 2025-10-15    # Announcement     ## Announcement  Exams 2 and 3 have each been moved a day earlier  * Exam 2: Monday, October 27th * Exam 3: Wednesday, November 19th  Exam review questions have been posted on Blackboard.    # Review: Adder and ALU Start       ## 4-Bit Adder and a Start to an ALU     ![4 Bit Adder](../../assets/images/adder_subtractor_4_bits.png)      ![4 Bit Adder](../../assets/images/alu_4_bits.png)        # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 0    ## Exercise  - Work on getting subtraction and `slt` working in your 4-bit ALU    ## Assignment  - [Assignment 5](../../assignments/assignment-5)   - make a 32-bit ALU   - `add`, `sub`, `and`, `or`, `not`, `xor`, `slt`, and anything else you want   - you can use Logisim's built-in components   - try not to duplicate circuitry for `add`, `sub`, and `slt`.   - submit screenshots of circuits *and* test vector (with comments)    # Sequential Logic     ## Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## S-R Latch     - A \"set reset\" latch is implemented with      - Let's fill in the truth table together              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 01      0 0 10      1 0 01      1 0 10      0 1 01      0 1 10           ## D Latch     - A \"data\" latch is implemented with      - Let's fill in the truth table together               $C$$D$$Q_\\text{next}$      0 0       0 1       1 0       1 1            ## Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)    ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png) ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-15-sequential-logic/",
        "teaser": null
      },{
        "title": "Registers Memory",
        "excerpt":"# Registers and Memory  ---  CS 130 // 2025-10-20    # Review     ## Sequential Logic - **Sequential** logic circuits have memory     +   Output depends on both the input and current state of memory     +   Behavior can change **over time**    ### Sequential Logic Components - **Clock**: a signal that oscillates between 0 and 1 -   **Latch**: 1-bit memory element that is updated when the clock is 1 -   **Flip Flop**: 1-bit memory element that is updated when the clock transitions from a 1 to a 0    ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)    ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png)    ## Exercise: Build a register File in Logisim     - 32 bits - at least 4 registers   ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file.png)      ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-writing.png)  ![Register File Diagram](/Fall2025/CS130/assets/images/COD/register-file-reading.png)   ![register file glimpse](../../assets/images/register_file_glimpse.png)          # ROM      ## ROM: Read-Only Memory   - Intended only to be read from (though it may be possible to change it in some circumstances) - **Non-volatile**: keeps its value without power - Game Cartidges, CD-ROM, DVD - Firmware for PCs and other devices   + contains boot-up instructions  ![CD ROM](../../assets/images/CD-ROM.png)  ![game cartridge](../../assets/images/gamecartridge.jpg)     # RAM     ## RAM: Random Access Memory - It takes the same amount of time to access data regardless of where it is   ![RAM modules](../../assets/images/ram.jpg)      ## Static Random Access Memory - Memory where data is stored *statically* with flip-flops - Faster than DRAM but less dense (lower capacity) and more expensive per bit - As long as it has power, SRAM will keep its value - Usually used for cache memory    ## Dynamic Random Access Memory - DRAM is the most dense RAM     * Implemented with capacitors instead of latches - stores energy in an electrical field - Must be occasionally \"refreshed\" because the capacitors slowly lose their stored values     * This is why it is called \"dynamic\" - Usually used for large capacity RAM  ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-20-registers-memory/",
        "teaser": null
      },{
        "title": "Instruction_memory_decode",
        "excerpt":"# Instruction Memory and Decode  ---  CS 130 // 2025-10-22     ## Instruction Memory on the CPU  ![Instruction Fetch](/Fall2025/CS130/assets/images/COD/instruction_fetch.png)    ## Demo: Make it in Logisim       Use a ROM to simulate instruction memory  - 16 bit address (should be 32 for MIPS, but that is too big for Logisim) - Quad output - so we can read four bytes at a time - lowest-address byte is shown first in Logisim memory contents      ![MIPS program in Logisim](../../assets/images/mips-for-logisim-rom.png)   ![MIPS program in MARS](../../assets/images/mips-for-logisim-mars.png)          ## Exercise    - Create a Program Counter Register which iterates through the instructions in memory   ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)    ## Exercise   - You can set your splitter to have custom fan-out ranges - Make a separate pin for each instruction field (opcode, rs, rt, etc.)       ![Custom Ranges for Splitter](../../assets/images/custom-splitter.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)        ## What's next?   * Use these circuits (or build your own)     - [Logisim Register File and ALU](https://ericmanley.github.io/Fall2025/CS130/assets/RegisterFileAndALU.circ) * Think about how you can hook up your decoded instruction to the register file and ALU so that it does the right thing for the instructions  ``` addi $9, $0, 7 addi $10, $0, 8 add $8, $9, $10 ```","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-22-instruction_memory_decode/",
        "teaser": null
      },{
        "title": "The Datapath",
        "excerpt":"# The Datapath  ---  CS 130 // 2025-10-29     # Continuing our Processor Design     ## Downloads if you need them    [Logisim Register File and ALU](https://ericmanley.github.io/Fall2025/CS130/assets/RegisterFileAndALU.circ)    ## 12:30 section progress  ![12:30 section datapath start](/Fall2025/CS130/assets/images/datapathstart1230.png)  * I was rushed to show you this working, but we forgot to hook up the *clock* and the register file's *write* enable    ## 2:00 section progress  ![2:00 section datapath start](/Fall2025/CS130/assets/images/datapathstart200.png)    ## What's next?  We have enabled `addi` instructions  ```mips  addi $8, $0, 5 ```  but what about a regular `add`?  ```mips  add $10, $8, $9 ```      ## Group discussion (12:30)  Where would you draw wires to support an `add`?  ![12:30 section datapath start](/Fall2025/CS130/assets/images/datapathstart1230.png)    ## Group discussion (2:00)  Where would you draw wires to support an `add`?  ![2:00 section datapath start](/Fall2025/CS130/assets/images/datapathstart200.png)   # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2025/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. Digital logic 3. **Processor architecture** 4. The C Programming Language    # Review      ## Review   - **CPU:** Central Processing Unit   - the circuits that execute instructions from a program   - AKA \"the processor\"   - Processor architecture   - logical design of CPU    - how do memory, the ALU, Register File, etc. all fit together?       ![Photo of the inside of a laptop](/Fall2025/CS130/assets/images/laptop-internal-components.png)  image from https://www.scientecheasy.com/2024/09/laptop-components.html/    ![Components of a processor](/Fall2025/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)      # The Datapath     ## The Datapath - What is a \"datapath\" and what does it consist of?     +   It is the main component of the CPU that executes instructions     +   Fetches instructions and data from memory, performs arithmetic, etc.     +   Consists of ALUs, a register file, RAM, and various supplementary logic gates    ## Instruction Execution 1. Uses the PC to fetch the next instruction to be executed from memory 2.   Identifies instruction type and registers involved and fetches their contents from the register file 3.   Depending on the instruction:     -   Uses the ALU to do appropriate arithmetic     -   Read/write RAM for load/store     -   Update PC to PC + 4 or the jump target address    # Building a Datapath     ## Instruction Fetch  ![Instruction Fetch](/Fall2025/CS130/assets/images/COD/instruction_fetch.png)    ## Review: Handling Instruction Fetch - We started this in Logisim  ![Instruction Memory in Logisim](../../assets/images/instruction-memory-logisim.png)      ## Decoding the Instruction   - You can set your splitter to have custom fan-out ranges      ![Decode Step](../../assets/images/decode.png)      ![R-Type format](../../assets/images/COD/r-type-instruction.png)  ![I-Type format](../../assets/images/COD/i-type-instruction.png)        ## R-Format Instructions  - Read two register operands, perform ALU operation, write result to target register  ![R-Format Instructions](/Fall2025/CS130/assets/images/COD/r_format_instructions.png)    ## Inputs to the Register File  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register Inputs](../../assets/images/reg_inputs.png)        ## Connecting it to the ALU  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   ![Register and ALU](../../assets/images/reg_file_outputs.png)       ## Load/Store Instructions  - Read register operands, calculate address, read/write to memory  ![Load-Store Instructions](/Fall2025/CS130/assets/images/COD/load_store_instructions.png)    ## Branch Instructions  - Read register operands, compare operands, calculate target address    ![Branch Instructions](/Fall2025/CS130/assets/images/COD/branch_instructions.png)    ## The Full Datapath    ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-10-29-the-datapath/",
        "teaser": null
      },{
        "title": "Control",
        "excerpt":"# Control  ---  CS 130 // 2025-11-03      # Review      ## MIPS CPU Diagram  ![Processor component diagram](/Fall2025/CS130/assets/images/COD/control.png)      ## 12:30 class: last time  ![Logisim Datapath Design](/Fall2025/CS130/assets/images/datapath1230.png)   **Discussion question:** this works for `add` and `addi`. What would need to change for it to work with `sub`?   ## 2:00 class: last time  ![Logisim Datapath Design](/Fall2025/CS130/assets/images/datapath200.png)   **Discussion question:** this works for `add` and `addi`. What would need to change for it to work with `sub`?         # Controlling CPU components     ### 12:30 Group Discussion  ![Logisim Datapath Design](/Fall2025/CS130/assets/images/datapath1230.png)  - In this picture, what still needs to be hooked up so that the whole thing is automated? - What do these all have in common? - What part of the instruction format will tell us what these things need to be set to?     ### 2:00 Group Discussion  ![Logisim Datapath Design](/Fall2025/CS130/assets/images/datapath200.png)  - In this picture, what still needs to be hooked up so that the whole thing is automated? - What do these all have in common? - What part of the instruction format will tell us what these things need to be set to?     #### Control Line Labels from the textbook with some additional annotation  ![R-Type format](../../assets/images/COD/datapath_with_control_annotated.png)     ## Control Behavior for add  ```mips  add $10, $8, $9 ```  ![R-Type format](../../assets/images/COD/r-type-instruction.png)   000000 01000 01001 01010 00000 100000  - When opcode is 000000 and funct is 100000...  - set ALUop to 000 (may be different for your ALU!)  - set RegWrite to 1  - set ALUSrc and RegDst to 0    ## Control Behavior for addi   ```mips  addi $8, $0, 5 ```  ![I-Type format](../../assets/images/COD/i-type-instruction.png)   001000 00000 01000 0000000000000101  - When opcode is 001000  - set ALUop to 000 (may be different for your ALU!)  - set RegWrite, ALUSrc, and RegDst to 1    ## Control Unit Design  - output depends on input $\\Rightarrow$ combinational circuit - can design a truth table, do sum of products, and make a PLA - Now that we know how to do it - let's let Logisim automate it for us!    Start of a truth table for our control unit:   ``` opcode[5..0] funct[5..0] | ALUop[2..0] RegWrite ALUSrc   RegDst 000000       100000      | 000         1        0        0      #add 001000       xxxxxx      | 000         1        1        1      #addi ```  save this to file `control_specification.txt`    ## Logisim directions      - Add a new circuit to your project, call it **control** - *Project* $\\rightarrow$ *Analyze Circuit* - Click *Import Table* button - Select your `control_specification.txt` file  - This will give you a warning - say *Yes* to ignore the errors and try again     ![Logisim load truth table](../../assets/images/circuit_from_truth_table.png)        - Click the *Build Circuit* button (if you get an error here, make sure you have Logisim version 3.7.2 installed) - Review and make sure you are not overwriting a different circuit in your project  - Click *OK*  ![build circuit](../../assets/images/build_circuit.png)     ## Hook it up to the datapath  ![Datapath with Control in Logisim](../../assets/images/logisim_cpu_simulated.png)   - simulate it  - use the **viewRegisterNum** and **RegisterContents** pins to see the values of registers as it executes    ## Exercise   - Update your Control Unit so that it works with   - `sub`   - `andi`  - [Assignment 6](../../assignments/assignment-6/): do these too      - `and`, `or`, `xor`, `andi`, `ori`, `xori`, `slt`, `slti`     - Extra Credit: do `lw`, `sw`, `beq`, and/or `bne`     - Or... design another instruction set and archtecture of your choosing       # Supporting More Instructions     ## Load Instruction  Let's describe what happens for a load operation like  ```mips  lw $8, 4($9) ```  100011 01001 01000 0000000000000100  ![Processor component diagram](/Fall2025/CS130/assets/images/COD/datapath_with_control_annotated.png)       ## Exercise: Store Instruction  Describe what happens for a store operation like  ```mips  sw $8, 4($9) ```  101011 01001 01000 0000000000000100  ![Processor component diagram](/Fall2025/CS130/assets/images/COD/datapath_with_control_annotated.png)       ## Exercise: Branches  Describe what happens for a branch instruction like  ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101   ![Processor component diagram](/Fall2025/CS130/assets/images/COD/datapath_with_control_annotated.png)     ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-11-03-control/",
        "teaser": null
      },{
        "title": "Instruction Execution",
        "excerpt":"# Instruction Execution  ---  CS 130 // 2025-11-05     ## Assignment 6 Reminder  - [Assignment 6](../../assignments/assignment-6/): do these too      - `and`, `or`, `xor`, `andi`, `ori`, `xori`, `slt`, `slti`     - Extra Credit: do `lw`, `sw`, `beq`, and/or `bne`     - Or... design another instruction set and archtecture of your choosing    # Datapath and Control Review      ## Example: `addi`  ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           Using this picture, highlight all datapath lines that are used and indicate what values they should have  Show the value each control line should have        ```mips  addi $8, $0, 5 ``` 001000 00000 01000 0000000000000101           ALUop: ALUSrc: Branch: MemRead: MemWrite: MemtoReg: RegWrite: RegDst:         # Supporting More Instructions: Load     ```mips  lw $8, 4($9) ```  100011 01001 01000 0000000000000100           ALUop: ALUSrc: Branch: MemRead: MemWrite: MemtoReg: RegWrite: RegDst:          # Exercises: Store and Branch      ```mips  sw $8, 4($9) ```  101011 01001 01000 0000000000000100           ALUop: ALUSrc: Branch: MemRead: MemWrite: MemtoReg: RegWrite: RegDst:             ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101           ALUop: ALUSrc: Branch: MemRead: MemWrite: MemtoReg: RegWrite: RegDst:              # Performance Issues     ## Performance Issues - Longest delay determines clock period -   Some stages of the datapath are idle waiting for others to finish -   Can improve performance by **pipelining**    # Pipelining     #### Breaking down instruction execution  - Five stages:     1. **IF**: Instruction Fetch       - read it from instruction memory     2. **ID**: Instruction Decode and Register Read      - split instruction into parts, read register data     3. **EX**: Execute      - ALU calculates result      4. **MEM**: Memory Access      - read from or write to memory     5. **WB**: Write back      - put new data back into a register      ## Pipeline Analogy - Suppose you need to do four loads of laundry - Each load of laundry needs to be     1. Washed via the washing machine     2. Dried via the dryer     3. Folded     4. Put away in the closet - For simplicity, assume that each task takes 30 mins    ## Pipeline Analogy - How long does it take to complete four loads? -   One approach uses only one stage at a time and does nothing in parallel:     ![nonpipelined_laundry](/Fall2025/CS130/assets/images/COD/unpipelined_laundry.png) -   Notice that the washer is unused 3/4 of the time    ## Pipeline Analogy - Another approach is harnessing parallelism by running independent stages simultaneously     ![pipelined_laundry](/Fall2025/CS130/assets/images/COD/pipelined_laundry.png) -   How much of a speedup does this approach give us?     +   $8/3.5 = 2.3\\times$ speedup     +   $2n/0.5n = 4\\times$ speedup if running continuously    ## Pipelined Datapath      ## Pipelined Datapath - Five stages:     1. **IF**: Instruction Fetch     2. **ID**: Instruction Decode     3. **EX**: Execute     4. **MEM**: Memory access     5. **WB**: Write back    ## Pipeline Performance - Assume time for stages is:     + `$100\\text{ps}$` for register read/write     + `$200\\text{ps}$` for other stages  ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/pipeline_performance_table.png)     ## Without a Pipeline ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/nonpipelined_mips_instructions.png)  - Why must the clock be set to `$800\\text{ps}$` when some instructions like `beq` could be completed in `$500\\text{ps}$`?     +   Clock speed is limited by **slowest** instruction: `lw`    ## With a Pipeline ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/pipelined_mips_instructions.png)  -   How much of a speedup does this approach give us?     +   `$2400/1400 = 1.7\\times$` speedup     +   `$800n/200n = 4\\times$` if running continuously    ## Pipeline Performance - Does using a pipeline increase the efficiency of executing **individual** instructions?     +   No, it slows them down from `$800\\text{ps}$` to `$1000\\text{ps}$`     +   Performance benefits come from increased **throughput** due to the parallelism    ## Why MIPS is Good for Pipelining - All MIPS instructions are the **same length**     + Easy to fetch instruction in cycle 1     + Easy to decode instruction in cycle 2 -   MIPS has only **a few instruction formats**     + Registers will always be in same location     + Easy to decode instructions ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-11-05-instruction-execution/",
        "teaser": null
      },{
        "title": "Pipelining",
        "excerpt":"# Pipelining  ---  CS 130 // 2025-11-10    ## Preparing for C programming  Installing what you need on your own computer [install guide](../../resources/installing-visual-studio-code)   or  Set up an account on GitHub and use Codespaces:   https://github.com/codespaces     ## Suggestions on using the RAM unit in your assignment        * Use 32 bit data width  * Use 16 bit address width, but only use some of the bits coming out of the ALU      # Review       ```mips  beq $8, $9, 5 #jump ahead 5 instructions ```  000100 01000 01001 0000000000000101           ALUop: \"sub\" ALUSrc: 0 Branch: 1 MemRead: 0 MemWrite: 0 MemtoReg: x RegWrite: 0 RegDst: x           # Performance Issues     ## Performance Issues - Longest delay determines clock period -   Some stages of the datapath are idle waiting for others to finish -   Can improve performance by **pipelining**    # Pipelining     #### Breaking down instruction execution  - Five stages:     1. **IF**: Instruction Fetch       - read it from instruction memory     2. **ID**: Instruction Decode and Register Read      - split instruction into parts, read register data     3. **EX**: Execute      - ALU calculates result      4. **MEM**: Memory Access      - read from or write to memory     5. **WB**: Write back      - put new data back into a register       ## Pipeline Analogy - Suppose you need to do four loads of laundry -   Each load of laundry needs to be     1. Washed via the washing machine     2. Dried via the dryer     3. Folded     4. Put away in the closet -   For simplicity, assume that each task takes 30 mins    ## Pipeline Analogy - How long does it take to complete four loads? -   One approach uses only one stage at a time and does nothing in parallel:     ![nonpipelined_laundry](/Fall2025/CS130/assets/images/COD/unpipelined_laundry.png) -   Notice that the washer is unused 3/4 of the time    ## Pipeline Analogy - Another approach is harnessing parallelism by running independent stages simultaneously     ![pipelined_laundry](/Fall2025/CS130/assets/images/COD/pipelined_laundry.png) -   How much of a speedup does this approach give us?     +   $8/3.5 = 2.3\\times$ speedup     +   $2n/0.5n = 4\\times$ speedup if running continuously    ## Pipelined Datapath      ## Pipelined Datapath - Five stages:     1. **IF**: Instruction Fetch     2. **ID**: Instruction Decode     3. **EX**: Execute     4. **MEM**: Memory access     5. **WB**: Write back    ## Pipeline Performance - Assume time for stages is:     + `$100\\text{ps}$` for register read/write     + `$200\\text{ps}$` for other stages  ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/pipeline_performance_table.png)     ## Without a Pipeline ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/nonpipelined_mips_instructions.png)  - Why must the clock be set to `$800\\text{ps}$` when some instructions like `beq` could be completed in `$500\\text{ps}$`?     +   Clock speed is limited by **slowest** instruction: `lw`    ## With a Pipeline ![Pipeline Performance](/Fall2025/CS130/assets/images/COD/pipelined_mips_instructions.png)  -   How much of a speedup does this approach give us?     +   `$2400/1400 = 1.7\\times$` speedup     +   `$800n/200n = 4\\times$` if running continuously    ## Pipeline Performance - Does using a pipeline increase the efficiency of executing **individual** instructions?     +   No, it slows them down from `$800\\text{ps}$` to `$1000\\text{ps}$`     +   Performance benefits come from increased **throughput** due to the parallelism    ## Why MIPS is Good for Pipelining - All MIPS instructions are the **same length**     + Easy to fetch instruction in cycle 1     + Easy to decode instruction in cycle 2 -   MIPS has only **a few instruction formats**     + Registers will always be in same location     + Easy to decode instructions    # Hazards     ## Hazards - Up until now, we have pretended that each instruction is **independent** of the others and that there are no conflicts -   In reality, instructions often depends on previous ones, which may cause naive pipelining to fail    ### Exercise  ```mips add $s0, $t0, $t1 sub $t2, $s0, $t3 ``` - What stage does `add` write the result of `$s0` into the register file?  - What stage does `sub` read from `$s0`?  - Why is this a problem?  - Can you think of any ways to fix this?    ## Types of Hazards - Situations that prevent immediately executing the next instruction in the pipeline are called **hazards** -   Three types of hazards:     1. Structure hazards     2. Data hazards     3. Control hazards    # Structure Hazards     ## Structure Hazards - In our laundry example, we were assuming the \"fold\" and \"put away\" stages could be done simultaneously     + However, if you are working by yourself, you would have to do them sequentially -   A **structure hazard** occurs when a required resource is busy performing another task    ## Structure Hazards - Recall that our MIPS pipeline has five stages:     + IF, ID, EX, MEM, WB -   The ID and WB stages read and write to the register file simultaneously     + Does this create a structure hazard?     +   No, by design, the register file supports simultaneous reading and writing    ## Structure Hazards - Suppose that we stored instruction memory and data memory in the same location     + Would this create a structure hazard?     +   Yes, the IF and the MEM stages would need to simultaneously read from the same memory     +   If using a single memory, the pipeline would need to **stall** to wait for the resource to become available    # Data Hazards     ## Data Hazards - A **data hazard** occurs when one instruction depends on the result of a previous instruction -   Our example:     ```mips     add $s0, $t0, $t1     sub $t2, $s0, $t3     ``` -   What stage does `add` write the result of `$s0` into the register file?     +   Stage 5: Write Back -   What stage does `sub` read from `$s0`?     +   Stage 2: Instruction Decode    ## Data Hazards - Would need to stall for two clock cycles in order to wait for the value $s0 to be available for reading  ![Data Hazard Stall](/Fall2025/CS130/assets/images/COD/data_hazard_stall.png)    ## Forwarding (aka Bypassing) - One way to avoid some data hazards without stalling is to **forward** the result to the next instruction immediately when it is available  ![Data Hazard Forwarding](/Fall2025/CS130/assets/images/COD/data_hazard_forwarding.png)    ### Discuss: What does this look like on the datapath?      ![Data Hazard Forwarding](/Fall2025/CS130/assets/images/COD/data_hazard_forwarding.png)             ## Forwarding (aka Bypassing) - Can you think of a situation where forwarding cannot resolve a data hazard?     ```mips     lw $s0, 20($t1)     sub $t2, $s0, $t3     ``` -   What stage does `lw` produce the bits of `$s0`?     +   After Stage 4: MEM    ## Forwarding (aka Bypassing)  - Why does this create an unavoidable stall?     ![Data Hazard Load Stall](/Fall2025/CS130/assets/images/COD/data_hazard_load.png)  -   We cannot send data **backwards in time**     ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` -   Assuming there is no forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code without forwarding?    ## Data Hazard Exercise - Consider the following MIPS code:     ```mips     lw $t0, 40($a3)     add $t6, $t0, $t2     sw $t6, 40($a3)     ``` - Assuming there IS forwarding implemented, are any stalls necessary? -   How many clock cycles are required to execute these three lines of code with forwarding?    ## Rearranging Instructions - Another way to avoid data hazards is by rearranging instructions - Consider the following MIPS code:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     lw  $t4, 8($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ``` -   Identify any stalls that are necessary even with forwarding and hazard detection active    ## Rearranging Instructions - These two stalls could be avoided by rearranging the code in the following way:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     lw  $t4, 8($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ```    # Control Hazards     ## Control Hazards - A **control hazard** (aka branching hazard) is when the next instruction to be executed is not yet known -   Caused by **branching** instructions such as `beq` -   During a `beq` instruction, at what pipeline stage do we know which branch will be taken?     +   After Stage 3: EX    ## Control Hazards - One way to avoid control hazards is by stalling     ![Stall on Branch](/Fall2025/CS130/assets/images/COD/stall_on_branch.png) -   After every branch statement, we stall for one cycle    ## Control Hazards - The pros of the \"always stall\" approach are:     1.   Simple and easy to understand     2.   Will always work -   The con of \"always stall\" is:     + It is slow    ## Control Hazards - An alternative to the always stall approach is **branch prediction**     + Make an educated guess on what the next instruction will be and execute that     +   If incorrectly guessed, \"undo\" the steps and go to the correct branch    ## Control Hazards - **Static branch prediction** will always predict a certain branch depending on the branching behavior     +   Predict forward branches not taken     +   Predict backward branches taken (loops) -   **Dynamic branch prediction** keeps track of how many times a branch is taken and updates its predictions based on history    # Pipelined Datapath Design     ## Pipelined Datapath Design     ## Using Registers (Has Bug)     ## Using Registers (Bug Fixed)      # Pipelined Control     ## Pipelined Control Simplified  ![Pipeline Control Simplified](/Fall2025/CS130/assets/images/COD/pipelined_control_simplified.png)    ## Pipelined Control Registers - Control signals derived from instruction and passed through the relevant registers  ![Pipeline Control Registers](/Fall2025/CS130/assets/images/COD/pipelined_control_registers.png)    ## Pipelined Control Complete      ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-11-10-pipelining/",
        "teaser": null
      },{
        "title": "Pipeline Hazards And Cache",
        "excerpt":"# Pipeline Hazards And Cache  ---  CS 130 // 2025-11-12     # Announcements        ## Preparing for C programming  Installing what you need on your own computer [install guide](../../resources/installing-visual-studio-code)   or  Set up an account on GitHub and use Codespaces:   https://github.com/codespaces    ## Preparing for Exam 3  * In class on Wednesday, November 19th * You may prepare and use one piece of 8.5\"x11\" paper with *your* handwritten notes * Check the review exercises posted on Blackboard    # Review     ## Review Discussion  - what is pipelining? - what is a pipeline hazard? - what are the different types of pipeline hazards? - what are some ways to deal with pipeline hazards?     ## Review: Data Hazards - A **data hazard** occurs when one instruction depends on the result of a previous instruction -   Our example:     ```mips     add $s0, $t0, $t1     sub $t2, $s0, $t3     ``` -   What stage does `add` write the result of `$s0` into the register file?     +   Stage 5: Write Back, *happens at time 5* -   What stage does `sub` read from `$s0`?     +   Stage 2: Instruction Decode, *happens at time 3*    ## Data Hazards - Would need to stall for two clock cycles in order to wait for the value $s0 to be available for reading  ![Data Hazard Stall](/Fall2025/CS130/assets/images/COD/data_hazard_stall.png)    ## Forwarding (aka Bypassing) - One way to avoid some data hazards without stalling is to **forward** the result to the next instruction immediately when it is available  ![Data Hazard Forwarding](/Fall2025/CS130/assets/images/COD/data_hazard_forwarding.png)    ## Forwarding (aka Bypassing) - Forwarding cannot always resolve a data hazard     ```mips     lw $s0, 20($t1)     sub $t2, $s0, $t3     ``` - What stage does `lw` produce the bits of `$s0`?     +   After Stage 4: MEM    ## Forwarding (aka Bypassing)  - Why does this create an unavoidable stall?     ![Data Hazard Load Stall](/Fall2025/CS130/assets/images/COD/data_hazard_load.png)  -   We cannot send data **backwards in time**     # More on Pipeline Hazards     ## Data Hazard Exercise  * Consider the following MIPS code: ```mips lw $t0, 40($a3) add $t6, $t0, $t2 sw $t6, 40($a3) ```  * Draw timing diagrams showing      * how many clock cycles are required when not doing forwarding     * how many clock cycles are required with forwarding - show the forwarding lines    ## Rearranging Instructions - Another way to avoid data hazards is by rearranging instructions - Consider the following MIPS code:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     lw  $t4, 8($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ``` -   We need to stall the first add (because it needs `$t2`) -   We need to stall the second add (because it needs `$t4`)    ## Rearranging Instructions - These two stalls could be avoided by rearranging the code in the following way:     ```mips     lw  $t1, 0($t0)     lw  $t2, 4($t0)     lw  $t4, 8($t0)     add $t3, $t1, $t2     sw  $t3, 12($t0)     add $t5, $t1, $t4     sw  $t5, 16($t0)     ```     # Control Hazards     ## Control Hazards - A **control hazard** (aka branching hazard) is when the next instruction to be executed is not yet known -   Caused by **branching** instructions such as `beq` -   During a `beq` instruction, at what pipeline stage do we know which branch will be taken?     +   After Stage 3: EX    ## Control Hazards - One way to avoid control hazards is by stalling     ![Stall on Branch](/Fall2025/CS130/assets/images/COD/stall_on_branch.png) -   After every branch statement, we stall for one cycle    ## Control Hazards - The pros of the \"always stall\" approach are:     1.   Simple and easy to understand     2.   Will always work -   The con of \"always stall\" is:     + It is slow    ## Control Hazards - An alternative to the always stall approach is **branch prediction**     + Make an educated guess on what the next instruction will be and execute that     +   If incorrectly guessed, \"undo\" the steps and go to the correct branch    ## Control Hazards - **Static branch prediction** will always predict a certain branch depending on the branching behavior     +   Predict forward branches not taken     +   Predict backward branches taken (loops) -   **Dynamic branch prediction** keeps track of how many times a branch is taken and updates its predictions based on history     # Pipelined CPU Design      ## Pipelined Control Complete       ### Pipelined Architecture with Hazard Detection and Forwarding         # Caches     ## Memory Organization - When a program uses memory, it tends to use it in *predictable ways*  -   As a result, it is possible to speed up memory usage dramatically by creating a **memory hierarchy**     +   Register file is small but it's ridiculously fast     +   SRAM is larger but slower     +   DRAM is larger still but even slower     +   Hard disks are HUGE but also the slowest    ## Terminology - **Cache:**     + An auxiliary memory from which high-speed retrieval is possible -   **Block:**     + A minimum unit of information that can either be present or not present in the cache -   **Hit:**     + CPU finds what it is looking for in the cache -   **Miss:**     + CPU doesn't find what it's looking for in the cache     ## Designing a Cache - Having a hierarchy of memories to speed up our computations is great, but we also face several design challenges -   If we are looking for a value in memory address `x`, how do we know if it is already in the cache?    ## Direct  Mapped Cache - One idea is to use a **direct mapped cache** where the address `$x_n$` tells us where to look in the cache -   If there are `n` slots in the cache, then we look for `x` in the `x % n` index of the cache    ## Direct Mapped Cache  ![Direct Mapped Cache](/Fall2025/CS130/assets/images/COD/direct_mapped_cache.png)    ## Direct Mapped Cache - If the number of blocks in the cache is `$n = 2^k$`, then `(x % n)` is simply the last `k` bits of `x`     + Makes it extremely efficient to find where a block is in the cache -   Since multiple blocks may have the same index in the cache, how do we know if the block of memory there is the one we're looking for?     +   Include a **tag** that uniquely identifies the block    ## Direct Mapped Cache - Some parts of the cache can be empty and/or underutilized if their index, by chance, doesn't pop up as often -   How can we improve utilization?    ## Fully Associative Cache - The \"extreme\" alternative to direct mapped caching is **fully associative** caching     + Any block can be stored in *any* index of the cache  ---  -   **Advantage**: Every spot in the cache will be used, and therefore less cache misses will occur -   **Disadvantage**: We need to search the entire cache every time, so the hit time will increase    ## Set-Associative Cache - The compromise between these approaches is the **set-associative** cache     + Blocks are *grouped* into sets of `n` blocks     + Block number determines which set -   Still requires searching through all `n` blocks in a set -   Can be tuned to have a decent balance between hit rate and hit time         ## Handling a Cache Miss 1. Check the cache for a memory address     + Results in a miss 2.   Fetch corresponding block from RAM or disk     + Wait for block to be retrieved (stall)     +   Write block to cache 3.   Continue pipeline (unstall)       **Exercise:** show what happens if the next three memory access are to addresses 10110, 00000, and 10111     ## Multilevel Caches - Usually, caches are implemented in multiple \"levels\" for maximal efficiency     +   L1 is smallest/fastest     +   L2 is larger/slower     +   L3 is largest/slowest -   Modern multi-core processors typically have dedicated L1 and L2 caches for each core and a shared L3 cache ","categories": [],
        "tags": [],
        "url": "/Fall2025/CS130/slides/2025-11-12-pipeline-hazards-and-cache/",
        "teaser": null
      }]
