var store = [{
        "title": "Lecture: Computer Organization",
        "excerpt":"# Computer Organization #### and Assembly Language Programming  ---  CS 130 // 2024-08-27    # Welcome! Instructor: Eric Manley  ---     **Office:** Collier-Scripps 327 **Email:**  **Phone:** (515) 271-2177     **Office Hours:** Schedule in Calendly the day before or drop inM 9:30am-12:30pmTh 2:00pm-4:00pm (tentative)         # Course Overview     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    So... what is a processor?     ![Photo of the inside of a laptop](/Fall2024/CS130/assets/images/COD/inside-laptop.png)    ![Components of a processor](/Fall2024/CS130/assets/images/COD/processor-components.png)    ![Processor component diagram](/Fall2024/CS130/assets/images/COD/control.png)    ![Compiler-Assembler Diagram](/Fall2024/CS130/assets/images/COD/compiler-assembler.png)     ## Major Aspects of the Course 1. Assembly language programming 2.   Digital logic 3.   Processor architecture 4.  The C Programming Language     #### Why should I learn this stuff?    Sometimes you really need to understand the system to solve your problems  ![Shazam movie poster](/Fall2024/CS130/assets/images/shazam-movie.jpg)    Wait, that's the wrong Shazam      #### Shazam - the transaction processing company  ![Transaction processing network](/Fall2024/CS130/assets/images/transaction-processing-network.png) - They hire developers in Des Moines - Need to process transactions fast  - If the Java garbage collector kicks in, they're in trouble    #### How does magic *really* work in our world?        ![Door to Moria](/Fall2024/CS130/assets/images/moria-door.webp)   ![Mistborn novel cover](/Fall2024/CS130/assets/images/mistborn-book.jpg)      ![Dungeons and Dragons spells](/Fall2024/CS130/assets/images/phb-spells.jpg)             ### My background with this course  - 1996-2004: C/C++ was my _native_ language -   2001: I took a course in _assembly_ and _digital circuits_     - didn't understand how it related to actual computers -   2003: Took an awful course on computer architecture     - deathly afraid of systems courses -   2005: ðŸ˜± assigned to teach _computer organization and assembly language programming_ in grad school     - ended up teaching it 8 semesters in a row    - 2007: ðŸ˜± took a qualifying exam on computer architecture     - read the entire textbook _and_ the sequel -   2009: got Ph.D.      - this stuff was an important part of my research     ![optical scalar multiplication](/Fall2024/CS130/assets/images/optical-scalar-mult.png) -   2022-2024: Teaching this course after 13 year break    # Course Logistics     ## Course Website   [https://ericmanley.github.io/Fall2024/CS130](https://ericmanley.github.io/Fall2024/CS130/)     #### What to do before coming to the next class    1. Read the [syllabus](https://ericmanley.github.io/Fall2024/CS130/syllabus) 2. From the [resources](https://ericmanley.github.io/Fall2024/CS130/resources) page  - If you don't have a JAVA SDK installed, install a Java SDK     - CS67 students - you can probably use the same one for both classes  - Download and run MARS - the MIPS simulator we'll be using     ## Warm up exercises  Get in groups discuss and write down your ideas  1. Rewrite the following code with one arithmetic operator (+, -, etc.) per line ```python pay = (salary + bonus) - (health_premium + taxes) ```  2. Rewrite lines of this form ```python a = b + c ``` like this ``` add a, b, c ```    ## Discussion Questions  1. What is the difference between computer _memory_ and the computer _disk_? 2. When using Excel spreadsheets, what causes something to be in memory? What causes something to be on the disk? 3. When writing a Python program, what causes something to be in memory? What causes something to be on the disk?    ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-08-27-introduction-to-computer-organization/",
        "teaser": null
      },{
        "title": "Mips Assembly Language",
        "excerpt":"## Introduction to # MIPS ---   CS 130 // 2024-08-29    # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2024/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. **Assembly language programming** 2. Digital logic 3. Processor architecture 4. The C Programming Language    # Assembly Languages     ## Assembly Languages - Every CPU architecture implements an **instruction set** which are the operations it natively supports -   The most common CPU architectures are:     + x86 (Intel/AMD)     +   ARM (Mobile phones, tablets, Apple's M1 chip, ...)  -   Instructions are extremely simple like ``` add a, b, c ```    ## Revisiting the Exercise from last time  A complicated line of high-level code like this ```python pay = (salary + bonus) - (health_premium + taxes) ```  Gets translated by the *compiler* into assembly code like ```bash add basepay, salary, bonus add deductions, health_premium, taxes sub pay, basepay, deductions ```      ## RISC vs. CISC - CPU architectures are usually categorized as either \"RISC\" or \"CISC\" -   RISC (Reduced Instruction Set Computing)     + Simplified instructions which \"do less\"     + ...but each instruction is highly optimized    ## RISC vs. CISC - CISC (Complicated Instruction Set Computing)     + Larger instruction set each of which \"does more\"     + Optimized so that a program can be implemented with few instructions---even though those instructions may take longer to execute    # MIPS     ## MIPS Architecture - In this course, we will be learning the MIPS instruction set     + \"Microprocessor without Interlocked Pipelined Stages\" - MIPS is a RISC processor with a minimalistic number of instructions - Is very similar to ARM     ## Discussion Question    - what exactly are `salary` or `taxes`  in this example?    ```python pay = (salary + bonus) - (health_premium + taxes) ```     ## Pointers  - In assembly programs, labels like `salary` or `taxes` are *pointers*  -   **pointer**: a stand-in for a _memory address_  -   Even this is too complicated for RISC ```bash add basepay, salary, bonus ```  -   You might first have to grab the data at the address indicated by the pointer _before_ you can do any operations on it.    ## Grabbing data from memory  - When we grab data from memory, where do we put it?  -   **Registers**: a holding place for data right inside the CPU   - data has to be in a register before you can perform operations    ![Processor component diagram](/Fall2024/CS130/assets/images/COD/control.png)    ## MIPS Architecture - Has 32 registers, each of which are 32-bits -   Why not include more registers?     +   Cost; registers are more expensive than RAM     +   Performance; more registers means slower clock     +   Instruction size; more registers means each instruction needs more bits to identify registers     #### A MIPS program in MARS  ![Processor component diagram](/Fall2024/CS130/assets/images/first_program.png)     #### Things to notice in MARS  - Registers have names like `$t0`, `$s2`, etc. - You can refer to a register by its name or number.    - `$t0` is also `$8` - MARS can be wonky   - MARS didn't play nice with OneDrive for me - you may need to create a folder for your `.asm` files in your home directory - `lw` means _load word_   - a **word** is a 32 bit value  ```mips #loads a value from memory location a into register $t0 lw $t0, a   ```        #### Exploration Exercise  1. Write the above program in MARS 2. What values are stored in each of the registers initially? 3. Find and press the **Assemble** button 4. What memory addresses did your *program* get stored in? 5. What memory addresses did your *data* get stored in? 6. Find and press the **Run** button 7. What values ended up in `$t0`, `$t1`, and `$t2`? Is that what you expected?    8. Change `a`'s initial value to 9 and rerun. What is in `$t2` now? What do you think is going on here? 9. Add the following to your data section ```mips result: 0 ``` 10. Add the following to the end of your text section ```mips sw $t2, result ``` 11. Rerun. Look in memory - is there a new value there? 12. What do you think `sw` means? 13. Try the **Run one step at a time** button and step through the program slowly. Watch the values change in the registers.     ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Interactive Program Exercise  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook  ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-08-29-mips-assembly-language/",
        "teaser": null
      },{
        "title": "Registers Instructions System Calls",
        "excerpt":"# Registers, Instructions, and System Calls  ---    CS 130 // 2024-09-03    # Review      ## Recap of last week  - MIPS: RISC architecture   + 32, 32-bit registers - We wrote some a simple MIPS program in Mars   + watched data change in registers and memory - Data and instructions get turned into binary and placed in memory     - Covered `add`, `lw`, `sw`  ```mips .data  a: 9 b: 3 result: 0   .text  lw $t0, a lw $t1, b add $t2, $t0, $t1 sw $t2, result ```    # More on Registers and Instructions      ## MIPS Register Conventions             Name Reg # Usage     $zero 0 Constant 0     $v0,...2-3 Values     $a0,...4-7 Arguments     $t0,...8-15 Temporaries     $s0,...16-23 Saved (variables)     $t8,...24-25 More temporaries     $gp28 global pointer     $sp29 stack pointer     $fp30 frame pointer     $ra31 return address             Register 1 is reserved for the assembler      Registers 26-27 are reserved for the OS      Only 8 $s registers (0..7)      Only 10 $t registers (0..9)        ## Exercise  - Write a MIPS program that does the equivalent of this high-level line of code ```python pay = (salary + bonus) - (health_premium + taxes) ```    ## Immediate values  - A literal value like 3 in the example below is called an **immediate value** - `li` means _load immedate_  ```mips .data  x: 5  .text  lw $t0, x li $t1, 3 #load 3 directly into $t1 add $t0, $t1, $t0 ```    ## I-type instructions  - There's also a variation of `add` where the second operand is replaced with an immediate value - `addi` means *add immediate*    - it's an **I-type instruction**  ```mips .data  x: 5  .text  lw $t0, x addi $t0, $t0, 3 ```     ## R-Type instructions  - The add instruction that uses only registers is an **R-type instruction**  ```mips add $t0, $t1, $t0 ```     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output Exercise  - Run this in MARS and discuss what happens with your neighbors - What do you think `.asciiz` does?  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### Input Exercise  - Run this in MARS and discuss what happens with your neighbors - Which register does the user's input go into?  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Assignment: Interactive Program  You now know enough to do the first assignment  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook       # Binary Numbers     ## Let's talk about how counting works  ![Odometer rollover](/Fall2024/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits? ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-03-registers-instructions-system-calls/",
        "teaser": null
      },{
        "title": "Numbers And Machine Code",
        "excerpt":"# Numbers and Machine Code  ---    CS 130 // 2024-09-05    # Announcements      ## Tutoring Lab is Open   - Cowles Library 201  - A tutor who can cover CS 130 will usually be there Sundays, Tuesdays, and Wednesdays from 7:30-9pm  - Please be understanding if they're not always able to help with CS 130      ## Student Research Groups  Friday, September 6th at 1:00pm in C-S 301  No experience required  Come to learn more about possible research groups in mathematics, computer science, math education, data science, cyber security, and more!    ## Vermeer-Drake Digital Bulldogs program   Application deadline is **October 15th** - 1-credit mentorship experience in spring  https://www.drake.edu/cs/internships/vermeerdigitalbulldogs/    # Review     ## System Calls  - We can make **system calls** to have the system perform things like input and output - Put the system call code in `$v0` - Put argument in `$a0` (and maybe `$a1` if needed)    #### Output a string  - a 4 in `$v0` means *print a string*  - **address** of the string should be in `$a0` - `la` means *load address*    - contrast with `lw` - use when you want the data *at the address* not the address itself, so use `lw` if you want to print an int  ```mips .data  message: .asciiz \"Hello!\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, message #the argument for the syscall syscall ```    #### User Input  - a 5 in `$v0` means *read an integer*  - whatever the user types gets put into `$v0` during the syscall  ```mips .data  prompt: .asciiz \"Enter an integer:\"  .text  li $v0, 4 #4 is the code for printing a string la $a0, prompt #the argument for the syscall syscall  li $v0, 5 #5 is the code for reading an integer syscall ```   #### Assignment: Interactive Program  You now know enough to do the first assignment  - [Assignment 1](../../assignments/assignment-1/): Write a program that interacts with the user and performs some kind of computation based on their input - Find other syscall codes on page B-44 of the textbook        # Binary Numbers     # CS Jokes  ![Only 10 types of people shirt](/Fall2024/CS130/assets/images/shirt10typesOfPeople.jpg)   Source: https://www.amazon.com/Types-People-understand-Binary-T-Shirt/dp/B07PSPLSC9    ## Let's talk about how counting works  ![Odometer rollover](/Fall2024/CS130/assets/images/Odometer_rollover.jpg)     How do you count if you only have two digits?     ## Counting in Binary - CPUs compute in **binary** using the contrast of low/high voltages to mean 0 and 1 - the two _binary digits_ or **bits** - So how do we encode **numbers** in binary?     ## Base 10 (AKA Decimal)  - When we write 437 we usually mean base 10 - the number system with 10 digits  - Can also write it as $437_\\text{ten}$   - $437_\\text{ten}$ means   `$$(4\\cdot 100)+(3\\cdot 10)+(7\\cdot 1)$$`  or  `$$(4\\cdot 10^2)+(3\\cdot 10^1)+(7\\cdot 10^0)$$`    ## Base 2 (AKA Binary)   $1101_\\text{two}$ means   `$$(1\\cdot 8)+(1\\cdot 4)+(0\\cdot 2)+(1\\cdot 1)$$`  or  `$$(1\\cdot 2^3)+(1\\cdot 2^2)+(0\\cdot 2^1)+(1\\cdot 2^0)$$`     ### Demo: Let's convert numbers to different bases   - $110110101_\\text{two}$  - $437_\\text{ten}$    ### Exercise: Practice with Binary - Convert the following number into decimal:     + $1011010_\\text{two}$ - Convert the following decimal number into binary:     + $277_\\text{ten}$      ### Base 16 (AKA Hexadecimal)  - Hexadecimal is base 16 - digits 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F - 5C means  `$$(5\\cdot 16)+(12\\cdot 1)$$`  - Easy to convert back and forth from binary    ### Counting in Binary/Hexadecimal              Decimal BinaryHex      0 0 0      1 1 1       2 102      3 11 3      4 1004      5 1015      6 1106      7 1117      8 1000 8                  Decimal BinaryHex      9 1001 9      10 1010A      11 1011 B      12 1100C      13 1101D      14 1110E      15 1111F      16 1000010      17 1000111            ### Exercise: Exploring in Mars    - Open up Mars and create a `.asm` file  - Put the number 302 in your data section - How does Mars display that in Hex? - What is the Binary equivalent?    ### Exercise: Convert back and forth    - Convert the following binary number into hex   - $\\text{1111 1010 0001 1011 0100 1110 0010 0011}_\\text{two}$ - Convert the following hexadecimal number into binary   - $\\text{00FF33AA}_\\text{hex}$    # Negative Numbers     ## Negative Numbers in Binary - We usually represent negative numbers by including a \"minus sign\" at the beginning of a number: $-437$ -   However, when representing numbers for logic circuits, we can **ONLY** use $0$s and $1$s. -   So what do we do?    ## Idea 1: Using a Sign Bit - We could treat the first bit of a number as the \"sign\" bit where $0$ means positive and $1$ means negative     + $10010$ is the same as $-0010$     + $01010$ is the same as $+1010$ -   Drawbacks     + Multiple representations for $0$     +   Addition/subtraction is not as convenient     +   Confusion over where the sign bit should be      ## Idea 2: Wrap Around  ![Odometer rollover](/Fall2024/CS130/assets/images/Odometer_rollover.jpg)   - Numbers \"wrap around\" from the **largest** number $999999$ to the **smallest** $000000$ -   We can do the same thing in binary!     +   If you add one to the largest number, it \"wraps around\" to the smallest negative number          # Two's Complement     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$        ## Two's Complement - Most processors are 32-bit or 64-bit, which means values sent to the processor are encoded in 32 or 64 bits, respectively -   In this class, we are using the MIPS 32-bit architecture -   Another way to think about two's complement is:      $1000\\\\;1001\\\\;1100\\\\;1010\\\\;0110\\\\;0110\\\\;0001\\\\;1110$      $(x_{31}\\cdot -2^{31}) + (x_{30}\\cdot 2^{30}) + \\cdots + (x_{1}\\cdot 2^{1}) + (x_{0}\\cdot 2^{0})$    ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$     ## Assignment is up  - [Assignment 2](../../assignments/assignment-2/)   - pen-and-paper    - convert some numbers between decimal, hexadecimal, and binary    # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2024/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2024/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2024/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## R-Type VS I-Type - Which type are each of the following instructions?     +   add     +   addi     +   sub     +   lw     +   sw    ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$   ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-05-numbers-and-machine-code/",
        "teaser": null
      },{
        "title": "Machine Code Logic Operations And Conditionals",
        "excerpt":"# Machine Code and Logic Operations  ---  CS 130 // 2024-09-10    ### Video shared by Jacob  Binary counting animation  https://www.reddit.com/r/Damnthatsinteresting/comments/ljyzoh/binary_to_20_visually_explained/    ![Career Fair flyer](/Fall2024/CS130/assets/images/careerfair2024.png)     # Negative Numbers in Binary     ## Negative Numbers in Binary - We usually represent negative numbers by including a \"minus sign\" at the beginning of a number: $-437$ -   However, when representing numbers for logic circuits, we can **ONLY** use $0$s and $1$s. -   So what do we do?    ## Idea 1: Using a Sign Bit - We could treat the first bit of a number as the \"sign\" bit where $0$ means positive and $1$ means negative     + $10010$ is the same as $-0010$     + $01010$ is the same as $+1010$ -   Drawbacks     + Multiple representations for $0$     +   Addition/subtraction is not as convenient     +   Confusion over where the sign bit should be      ## Idea 2: Wrap Around  ![Odometer rollover](/Fall2024/CS130/assets/images/Odometer_rollover.jpg)   - Numbers \"wrap around\" from the **largest** number $999999$ to the **smallest** $000000$ -   We can do the same thing in binary!     +   If you add one to the largest number, it \"wraps around\" to the smallest negative number          # Two's Complement     ## Two's Complement - Most computers use **two's complement** to encode signed integer values - What is it exactly?     +   Non-negative numbers are represented as usual$0000$, $0011$, $0110$     +   To negate a number, you do the following:         1. Flip all the bits: $0\\rightarrow 1$ and $1\\rightarrow 0$         2. Add 1 to the result     +   $0000$, $1101$, $1010$        ## Two's Complement - Most processors are 32-bit or 64-bit, which means values sent to the processor are encoded in 32 or 64 bits, respectively -   In this class, we are using the MIPS 32-bit architecture -   Another way to think about two's complement is:      $1000\\\\;1001\\\\;1100\\\\;1010\\\\;0110\\\\;0110\\\\;0001\\\\;1110$      $(x_{31}\\cdot -2^{31}) + (x_{30}\\cdot 2^{30}) + \\cdots + (x_{1}\\cdot 2^{1}) + (x_{0}\\cdot 2^{0})$    ## Exercise ### Two's Complement Practice - Convert each of the following numbers to decimal:  ---  - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111$ - $1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1111\\\\;1110\\\\;0101$ - $0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0000\\\\;0101$     ## Assignment is up  - [Assignment 2](../../assignments/assignment-2/)   - pen-and-paper    - convert some numbers between decimal, hexadecimal, and binary    # MIPS Machine Code     ## MIPS Machine Code - Each MIPS instruction is encoded in 32-bits     +   `add` `$t0`, `$s1`, `$s2`     +   000000 10001 10010 01000 00000 100000  ---  ![R-Type Instruction](/Fall2024/CS130/assets/images/COD/r-type-instruction.png)     ## R-Type Instructions ![R-Type Instruction](/Fall2024/CS130/assets/images/COD/r-type-instruction.png)  ---  1.   `op` (6 bits): Opcode 2.   `rs` (5 bits): First operand register 3.   `rt` (5 bits): Second operand register 4.   `rd` (5 bits): Destination register (result) 5.   `shamt` (5 bits): Shift amount 6.   `funct` (6 bits): Function code    ## I-Type Instructions ![I-Type Instruction](/Fall2024/CS130/assets/images/COD/i-type-instruction.png)  ---  1. `op` (6 bits): Opcode 2. `rs` (5 bits): First operand register 3. `rt` (5 bits): Second operand register 4.   `data` (16 bits): Constant or address    ## Exercise  - Use Mars to figure out how each of the following is represented in bits (convert from hex!). ```mips add $t2, $t1, $t0 sub $t2, $t1, $t0 addi $t0, $t0, 3 ``` - What are the opcodes for `add`, `sub`, and `addi`?     ## R-Type VS I-Type - Why do we need the I-type? Why not just implement `addi`, `lw`, and `sw` using the R-type format?     +   Allows us to specify larger addresses and constants     +   $2^5 = 32$ and $2^{16} = 65536$     # Logical Operations     ## Boolean values - Suppose I create a `bool` variable in Python:     ```py     b = True     ``` -   How many bits of memory were just allocated?     +   An entire word!     +   `b` is a **memory address** that \"points to\" `True`    ## Logical operator investigation     Before executing: guess what you think `$t0`-`$t5` will be   Execute it: were you right?  Is this how `and` and `or` behave in Python?    ```mips    .text     li $s0, 0    li $s1, 1    li $s2, 2    li $s3, 3        and $t0, $s0, $s1    or $t1, $s0, $s1    andi $t2, $s1, 1    ori $t3, $s1, 0        or $t4, $s1, $s2    and $t5, $s2, $s3 ```       ## Set on Less Than investigation     Before executing: guess what you think `$t0`-`$t5` will be  Execute it: were you right?  What do `sle` and `sgt` mean? What do they get translated into by the assemler?    ```mips .text   li $s1, 2 li $s2, 2 li $s3, 3  #slt: \"set on less than\" slt $t0, $s2, $s3 slt $t1, $s1, $s2 slt $t2, $s3, $s2 slti $t3, $s3, 10  #psuedoinstructions sle $t4, $s1, $s3 sle $t5, $s1, $s2 sgt $t6, $s3, $s2 ```       ## Shifting investigation     Execute it: what do `sll` and `srl` do?  What happens if you shift an odd number?  Are these R-Type or I-Type instructions?    ```mips .text   li $s0, 16  #shift left logical sll $t0, $s0, 1 sll $t1, $s0, 2  #shift right logical srl $t2, $s0, 2 ```        # Conditionals     ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```   ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-10-machine-code-logic-operations-and-conditionals/",
        "teaser": null
      },{
        "title": "Logic And Branching",
        "excerpt":"# Logic and Branching  ---  CS 130 // 2024-09-12      # Logical Operations     ## Boolean values - Suppose I create a `bool` variable in Python:     ```py     b = True     ``` -   How many bits of memory were just allocated?     +   An entire word!     +   `b` is a **memory address** that \"points to\" `True`    ## Logical operator investigation     Before executing: guess what you think `$t0`-`$t5` will be   Execute it: were you right?  Is this how `and` and `or` behave in Python?    ```mips    .text     li $s0, 0    li $s1, 1    li $s2, 2    li $s3, 3        and $t0, $s0, $s1    or $t1, $s0, $s1    andi $t2, $s1, 1    ori $t3, $s1, 0        or $t4, $s1, $s2    and $t5, $s2, $s3 ```       ## Set on Less Than investigation     Before executing: guess what you think `$t0`-`$t5` will be  Execute it: were you right?  What do `sle` and `sgt` mean? What do they get translated into by the assemler?    ```mips .text   li $s1, 2 li $s2, 2 li $s3, 3  #slt: \"set on less than\" slt $t0, $s2, $s3 slt $t1, $s1, $s2 slt $t2, $s3, $s2 slti $t3, $s3, 10  #psuedoinstructions sle $t4, $s1, $s3 sle $t5, $s1, $s2 sgt $t6, $s3, $s2 ```       ## Shifting investigation     Execute it: what do `sll` and `srl` do?  What happens if you shift an odd number?  Are these R-Type or I-Type instructions?    ```mips .text   li $s0, 16  #shift left logical sll $t0, $s0, 1 sll $t1, $s0, 2  #shift right logical srl $t2, $s0, 2 ```       # Conditionals      ## Branching - **Branching** allows MIPS programs to skip around to different parts of the program - Useful for     - conditional statements (if, if-else, etc.)     - loops    - continue executing at the line labeled `my_label` ```mips b my_label #... my_label: ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are equal ```mips beq $s0, $s1, my_label ``` -   continue executing at the line labeled `my_label` if `$s0` and `$s1` are _not_ equal ```mips bne $s0, $s1, my_label ```     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```          ## Exercise  - Run the above program in Mars, observe the output - Change it so `i` and `j` are equal, run again - Translate the following Python program into MIPS ```python     if i == j:         k = 1     else:         k = 2      print(\"The value of k is\",k) ```       ## Compiling a `while` Statement  ```python i = 1 while i != 10:      print(i)    i += 1 ```  ---  ```mips .text \tli $s0, 1 \tli $t0, 10 \t start_loop: \tbeq $s0, $t0, done  \tli $v0, 1 #print integer - no newline after! \tadd $a0, $s0, $zero #copy $s0 into $a0 \tsyscall  \taddi $s0, $s0, 1 \tb start_loop  done: ```      ## Exercise  - Translate this into MIPS - Hint: can you use `slt` here?  ```python sum = 0 i = 0  while i     ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has both an if statement and a loop    # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array - The other version: `la $t0, a` \t- pseudoinstruction     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2024/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data   my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"       .text  \tla $s0, my_array #load the base address of the array \tli $t0, 0 #loop counter  loop:  \tslti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-12-logic-and-branching/",
        "teaser": null
      },{
        "title": "Arrays And Procedures",
        "excerpt":"# Arrays and Procedures  ---  CS 130 // 2024-09-17      # Announcement      ## Exam 1  * Originally scheduled for next week on Tuesday * Pushing it back to **Thursday, September 26th** * We will try it asynchronous - done on your own time outside of class * I will give you several days in which to complete it * Individual, no collaboration of any kind * Open book/notes * No AI, no Internet outside of class resources * If you were to use a resource (even if you weren't supposed to), you need to cite it    ### Kinds of Questions  Blackboard test tool * free response * multiple choice * fill-in-the-blank     # Review     ## Compiling an `if` Statement         ```python     if i == j:         k = 1      print(\"The value of k is\",k) ```     ```mips .data  i: 5 j: 8 k: 0 message: .asciiz \"The value of k is \"  .text  \tlw $s0, i \tlw $s1, j \t \tbne $s0, $s1, disp_msg \tli $s2, 1 \tsw $s2, k  disp_msg: \tli $v0, 4 #4 is the code for printing a string \tla $a0, message #the argument for the syscall \tsyscall  \t \tli $v0, 1 #1 is the code for printing an int \tlw $a0, k #the argument for the syscall \tsyscall  ```         # Loops     ## Compiling a `while` Statement  ```python i = 1 while i != 10:      print(i)    i += 1 ```  ---  ```mips .text \tli $s0, 1 \tli $t0, 10 \t start_loop: \tbeq $s0, $t0, done  \tli $v0, 1 #print integer - no newline after! \tadd $a0, $s0, $zero #copy $s0 into $a0 \tsyscall  \taddi $s0, $s0, 1 \tb start_loop  done: ```      ## How can we do less than?   - How can you use the `slt` instruction with this?  ```python sum = 0 i = 0  while i     ## Assignment  - [Assignment 3](../../assignments/assignment-3/)   - Translate a Python program that has both an if statement and a loop    # Arrays     ## What is an array?         An array is a series of data items stored in consecutive memory locations  - Python: list   - Java: array, ArrayList  - C/C++: array, Vector      ## Example array program  ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4   .text  la $s0, my_array #load the base address of the array  #Addresses go up by 4 because each byte has its own address #So a word takes up 4 addresses lw $t0, 0($s0) #load my_array[0] lw $t1, 4($s0) #load my_array[1] lw $t0, 8($s0) #load my_array[2] lw $t0, 12($s0) #load my_array[3] ```    ### New flavor of `lw`  ```mips lw $t1, 4($s0) #load my_array[1] ```  - Meaning     - load the 32-bit value stored at the address `$s0`+4 - Good for accessing items in an array     ## Arrays in memory   ```mips .data   #arrays get stored in consecutive 32-bit memory addresses  my_array: 1, 2, 3, 4 ```  ![array in Mars memory](/Fall2024/CS130/assets/images/array-in-memory.png)    ### Translating a program that uses an array     ```python     my_array = [10,6,0,27,92,18,42]     i = 0      while i    ```mips .data   my_array: 10, 6, 0, 27, 92, 18, 42 newline: .asciiz \"\\n\"       .text  \tla $s0, my_array #load the base address of the array \tli $t0, 0 #loop counter  loop:  \tslti $t1, $t0, 7 #check if loop counter          ## Exercise  - edit the above MIPS program to also find the sum of all the items in the array      # Procedures     ### Compile a Simple Leaf Procedure  ```python def func(x,y):     return x + y ```  ---  ```mips func: add $v0, $a0, $a1       jr  $ra ```  * the first argument to the procedure is in `$a0` * the second argument to the procedure is in `$a1` * the return value of the procedure goes in `$v0` * `jr`: jump to the instruction whose address is in register `$ra`       ```mips func: add $v0, $a0, $a1       jr  $ra ```  When you call this function, you must * put the first argument in `$a0` * put the second argument in `$a1` * put the **return address** in `$ra` * jump to the function    ### Calling Our Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure      ### Nested Procedure Calls  ```python def main():     func(1, func(2, func(3, 4))) ```  ---  ```mips main:     li  $a0, 3     li  $a1, 4     jal func      li   $a0, 2     move $a1, $v0     jal  func      li   $a0, 1     move $a1, $v0     jal  func ``` **remember:** `$v0` is where we find the returned value       ## Calling a Procedure 1. Put parameters in appropriate registers     +   `$a0`, `$a1`, `$a2`, `$a3` 2.   Transfer control to the procedure: *jump and link*     +   `jal ProcedureLabel` \t- puts the current instruction's address into `$ra` 3.   Perform task 4.   Place result in a location the callee can find     +   `$v0`, `$v1` 5.   Return control to the caller: *jump to addr. in register*     +   `jr $ra`     ## Exercise - Convert the following Python code into MIPS - Make sure to create two functions     - make sure the print happens in `main`, not `double_it`  ```python def double_it(e):     return e + e  def main():     print( double_it(21) ) ```    ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-17-arrays-and-procedures/",
        "teaser": null
      },{
        "title": "Procedures",
        "excerpt":"# Procedures  ---  CS 130 // 2024-09-19      # Procedures     ### Compile a Simple Leaf Procedure  ```python def func(x,y):     return x + y ```  ---  ```mips func: add $v0, $a0, $a1       jr  $ra ```  * the first argument to the procedure is in `$a0` * the second argument to the procedure is in `$a1` * the return value of the procedure goes in `$v0` * `jr`: jump to the instruction whose address is in register `$ra`       ```mips func: add $v0, $a0, $a1       jr  $ra ```  When you call this function, you must * put the first argument in `$a0` * put the second argument in `$a1` * put the **return address** in `$ra` * jump to the function    ### Calling Our Leaf Procedure  ```python def func(x,y):     return x + y  def main():     func(1, 2) ```  ---  ```mips func:     add $v0, $a0, $a1     jr $ra  main:     li  $a0, 1 #load the first argument     li  $a1, 2 #load the second argument     jal func ``` `jal`: **jump and link** - put the next instruction's address in `$ra` and jump to the procedure      ### Nested Procedure Calls  ```python def main():     func(1, func(2, func(3, 4))) ```  ---  ```mips main:     li  $a0, 3     li  $a1, 4     jal func      li   $a0, 2     move $a1, $v0     jal  func      li   $a0, 1     move $a1, $v0     jal  func ``` **remember:** `$v0` is where we find the returned value      ## Calling a Procedure  1. Put parameters in appropriate registers   + `$a0`, `$a1`, `$a2`, `$a3` 2. Transfer control to the procedure: *jump and link*   + `jal ProcedureLabel`     - puts the current instruction's address into `$ra` 3. Perform task 4. Place result in a location the callee can find   + `$v0`, `$v1` 5. Return control to the caller: *jump to addr. in register*   + `jr $ra`     ## Exercise - Convert the following Python code into MIPS - Make sure to create two functions     - make sure the print happens in `main`, not `double_it`  ```python def double_it(e):     return e + e  def main():     print( double_it(21) ) ```     ## Non-Leaf Procedures - Life would be easy if all procedures were \"leaves\" - In reality, a procedure might call another procedure which may call another procedure ... \t- could even be *recursive* -   We need a way to preserve the state of each partially completed call so that they all return properly     # Stack     ## Stack - MIPS provides a register `$sp` that stores a memory address -   Addresses **above** `$sp` is memory that is already being used by other parts of the program -   Addresses **below** `$sp` is free memory    ## Stack - The **called** procedure is responsible for restoring any saved registers `$s0`, ..., `$s7` as well as the stack pointer `$sp` register before returning -   Any other register may be used without restoration, so the **calling** procedure is responsible for saving any data before making the call    ## Memory Structure ![MIPS memory structure](/Fall2024/CS130/assets/images/COD/mips-memory.png)    ## Stack Frames ![Procedure frame](/Fall2024/CS130/assets/images/COD/stack-frame.png)      ## Exercise - Convert the following C code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: Compute  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 4](../../assignments/assignment-4/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.  ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-19-procedures/",
        "teaser": null
      },{
        "title": "Logic Gates And Truth Tables",
        "excerpt":"## Logic Gates and Truth Tables  ---  CS 130 // 2024-09-24     ## Reminder  * Exam 1 is up and is due by the end of the day on Thursday * Make sure to read the instructions * We will not meet for class on Thursday * I will be here if you want to come and work on the exam or Assignment 4      ## Vermeer Digital Bulldogs  https://www.drake.edu/cs/internships/vermeerdigitalbulldogs/  Deadline is October 15th      # Finishing up Procedures      ## Stack Frames ![Procedure frame](/Fall2024/CS130/assets/images/COD/stack-frame.png)      ## Exercise from last time - Convert the following C code into MIPS  ```python def double_it(e):     return e + e  def calc(c):     d = double_it(7)     return c + d  def main():     a = 5     b = calc(a) ```    ## Exercise Solution: Compute  ```python def double_it(e):     return e + e ```  ```mips double_it: add $v0, $a0, $a0    # returns e + e          jr $ra ```      ## Exercise Solution: Calc - Take 1  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: li  $a0, 7          # puts 7 in a0       jal double_it         # calls compute(7)       add $v0, $v0, $a0   # adds argument to result       jr  $ra ```    -   Unfortunately this will fail. Why?     +   Both `$a0` and `$ra` will be erased!    ## Exercise Solution: Calc - Take 2  ```python def calc(c):     d = double_it(7)     return c + d ```  ```mips calc: addi $sp, $sp, -8    # allocates space       sw   $a0, 0($sp)     # stores c on the stack       sw   $ra, 4($sp)     # stores $ra on the stack       li   $a0, 7          # puts 7 in a0       jal  double_it       # calls double_it(7)       lw   $ra, 4($sp)     # restores $ra       lw   $a0, 0($sp)     # restores argument       addi $sp, $sp, 8     # deallocates space       add  $v0, $v0, $a0   # adds argument to result       jr   $ra ```      ## Exercise Solution: Main  ```python def main():     a = 5     b = calc(a) ```  ```mips main:    li   $s0, 5          # a = 5          move $a0, $s0        # loads a into argument          jal  calc            # calls calc(5)          move $s1, $v0        # b = result ```      ## Assignment  - [Assignment 4](../../assignments/assignment-4/)   - Translate a Python program that has functions and Arrays   - 8 points   - Part of it has been done - you'll do a \"middle\" function.    ### Preparing for part 2 of the course  We will soon be using a digital logic simulator called Logisim-Evolution   * [Information here](https://github.com/logisim-evolution/logisim-evolution) * [Download here](https://github.com/logisim-evolution/logisim-evolution/releases/tag/v3.7.2) - make sure to get v3.7.2   - **jar** file: should work for anyone (similar to MARS)   - **msi** file: installer for Windows (you probably want x86 version)   - **dmg** file: installer for Mac (may or may not work for M1/M2/M3 Macs)     # Course Themes     ## Overarching Theme - Learning how a high-level program is actually executed on your computer's processor    ![Compiler-Assembler Diagram](/Fall2024/CS130/assets/images/COD/compiler-assembler.png)    ## Trajectory of the Course 1. Assembly language programming 2. **Digital logic** 3. Processor architecture 4. The C Programming Language    ## Basic CPU Operations - Recall that most operations operate on one or more 32-bit registers     +   `add $s0,` `$s1`, `$s2` takes two 32-bit numbers, adds them up, and produces a new 32-bit number -   How can we build a machine that takes 0s and 1s as input and produces 0s and 1s as output?    # Digital Logic   NOTE: Discuss how hard electrical engineering is and why it is so useful to focus on the simplicity of digital logic    ## Transistors - CPU instructions are implemented with nanoscale switches called **transistors**     ![Light bulb](https://makercise.com/wp-content/uploads/2015/11/vlcsnap-2015-11-17-20h50m57s882.png.jpg)       You can think of a transistor as a \"switch\" with states \"on\" and \"off\"         ## Digital Logic - Learning about electricity, capacitors, resistors, is beyond the scope of this course -   For now, it is useful to abstract away the details of electrical engineering -   We will think about circuits in terms of 0s and 1s going through the wires of a circuit    ## Input/Output as Voltages    - The 0s and 1s of our circuits will be \"low\" and \"high\" voltages across a wire, similar to a light bulb being \"on\" and \"off\"     ![Bits as light bulbs](https://miro.medium.com/max/2400/1*Um-qKrB2QLxRU0C8CkCCeg.png)        ## Logic Gates - A **logic gate** is an elementary circuit that takes one or more bits as input and produces one or more bits as output -   Many of these logic gates can be constructed with one or two transistors    ## AND Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       0                 1       0       0                 1       1       1           ![AND Gate](/Fall2024/CS130/assets/images/gates/and.png)    ## OR Gate                 Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       1            ![OR Gate](/Fall2024/CS130/assets/images/gates/or.png)      ## NOT Gate                 Input       Output                 0       1                 1       0           ![NOT Gate](/Fall2024/CS130/assets/images/gates/not.png)      ## NAND Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       1                 1       0       1                 1       1       0           ![NAND Gate](/Fall2024/CS130/assets/images/gates/nand.png)     ## NOR Gate                 Input 1       Input 2       Output                 0       0       1                 0       1       0                 1       0       0                 1       1       0           ![NOR Gate](/Fall2024/CS130/assets/images/gates/nor.png)     ## XOR Gate                  Input 1       Input 2       Output                 0       0       0                 0       1       1                 1       0       1                 1       1       0           ![XOR Gate](/Fall2024/CS130/assets/images/gates/xor.png)  (exclusive OR)    ### Demo: What is the truth table for the following circuit?  ---     ![Simple circuit](/Fall2024/CS130/assets/images/gates/simple-circuit.png)                    A       B       C       D                 0       0       0                         0       0       1                         0       1       0                         0       1       1                         1       0       0                         1       0       1                         1       1       0                         1       1       1                         #### Exercise   1. Fill out the truth table 2. Describe what the circuit does using words      ![Simple circuit](/Fall2024/CS130/assets/images/gates/xorcise.png)                    A       B       C                 0       0                         0       1                         1       0                         1       1                       *NB:* a filled dot where wires cross means that the wire splits. If no dot appears, it means one wire is routed over the top of the other.    ### Symbolically describing a circuit         ![Simple circuit](/Fall2024/CS130/assets/images/gates/simple-circuit.png)           $$D = \\overline{(A\\cdot B)} + (B \\cdot C)$$      - $\\overline{A}$ \"not $A$\" - $\\cdot$ \"and\" - $+$ \"or\"    ### Exercise  Symbolically describe the circuit  ![Simple circuit](/Fall2024/CS130/assets/images/gates/xorcise.png)    ### Exercise  1. Draw a circuit representing the logic symbols 2. Write the truth table for the circuit  $$ C = (A \\cdot \\overline{S}) + (B \\cdot S) $$    ### Challenge Exercise       Can you come up with a circuit that has this truth table? - A, B, and C are inputs - E is an output  Verbally describe what this circuit does.   Write the logic symbols representing this circuit.                    A       B       C       E                 0       0       0       0                 0       0       1       1                 0       1       0       1                 0       1       1       0                 1       0       0       1                 1       0       1       0                 1       1       0       0                 1       1       1       1              ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-09-24-logic-gates-and-truth-tables/",
        "teaser": null
      },{
        "title": "Combinational Logic",
        "excerpt":"# Combinational Logic  ---  CS 130 // 2024-10-01    # Digital Logic Review            ## Boolean Algebra - We can represent logic gate computations as using **Boolean algebra** -   $\\overline{A}\\cdot B+A\\cdot C$ means the same thing as:     + `((not A) and B) or (A and C)`    ## Universal Gates - The **NAND** gate and the **NOR** gate are \"universal\" and can be used to construct every other gate - Using only **NAND** gates, construct circuits that are equivalent to NOT, AND, and OR gates  ![NOT from NAND](/Fall2024/CS130/assets/images/NOT_from_NAND.png) ![AND from NAND](/Fall2024/CS130/assets/images/AND_from_NAND.png) ![OR from NAND](/Fall2024/CS130/assets/images/OR_from_NAND.png)    ### Multiplexor From Last Time        $$ C = (A \\cdot S) + (B \\cdot \\overline{S}) $$  ![Multiplexor Circuit Diagram](/Fall2024/CS130/assets/images/multiplexor_diagram.png)                     A       B       S       C                 0       0       0       0                 0       0       1       0                 0       1       0       1                 0       1       1       0                 1       0       0       0                 1       0       1       1                 1       1       0       1                 1       1       1       1                 #### Demo: Designing and Testing Circuits with Logisim  [Installing Logisim](../../resources/installing-logisim/)  ![Multiplexor Circuit Diagram](/Fall2024/CS130/assets/images/logisim_multiplexor.png)     # Combinational Logic     ## Combinational Logic - **Combinational** logic circuits don't have memory     +   Output depends on only the input     +   Can be completely specified by a truth table -   **Sequential** logic circuits do have memory     +   Output depends on both the input and current state of memory    ## Sum of Products Form - All combinational circuits can be converted to a **sum of products** form that makes them especially easy to implement with gates  ---     -   Need to identify the 1s in the output -   Construct a product term such as $\\overline{A}\\cdot\\overline{B}\\cdot C$ for each 1 in output -   \"Sum\" them together             A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ### Example       $\\overline{A}\\cdot\\overline{B}\\cdot C$  + $\\overline{A}\\cdot B\\cdot \\overline{C}$   +  $A \\cdot \\overline{B}\\cdot \\overline{C}$   +  $A \\cdot B \\cdot C$                 A B C  D       0 0 0  0       0 0 1  1       0 1 0  1       0 1 1  0       1 0 0  1       1 0 1  0       1 1 0  0       1 1 1  1           ## Exercise: Sum of Products                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1           - Write-out the sum-of-products for this truth table    + Inputs are A, B, C.     + Outputs are Y1, Y0   - Draw the circuit by hand   - Draw the circuit in Logisim    + Manually test some inputs   - Create a run test vector     *NB:* circuits built from the sum-of-products have two stages - ANDs then ORs   - this is called a **programmable logic array** or PLA        ## Assignment  - [Assignment 5](../../assignments/assignment-5/)   - Given a truth table, design a circuit   - Use sum-of-products   - implement it in Logisim   - test it with a test vector   - submit screenshot      ## Decoder - A **decoder** is another common circuit that has $n$ inputs and $2^n$ outputs -   Only one output is a 1 at any given time (one for each possible combination of inputs) -   If the input encodes the number 7, then the output bit for 7 is asserted and all others are zeros    ## Decoder Truth Table  - Below is a 3-bit decoder truth table  ![Decoder Truth Table](../../assets/images/COD/decoder.png)   ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-10-01-combinational-logic/",
        "teaser": null
      },{
        "title": "Constructing Adder And Alu",
        "excerpt":"## Constructing an Adder and an ALU  ---  CS 130 // 2024-10-03     # One-bit Adder     #### Full Adder: Circuit that adds three bits                A B CY1 Y0      0 0 00 0      0 0 10 1      0 1 00 1      0 1 11 0      1 0 00 1      1 0 11 0      1 1 01 0      1 1 11 1                   ![Full Adder](../../assets/images/combinational_FA.png)             # Four-bit Adder     ## Demo: constructing a 4-bit adder from 1-bit full adders  ![4 Bit Adder](../../assets/images/adder4bits.png)  [Adder test vector](../../assets/adder4bit_test_vector.txt)     # ALU     ## The ALU - What does ALU stand for?     + Arithmetic Logic Unit -   What does an ALU do?     + Does all the logical and arithmetic operations of the CPU    ## Basic ALU - The simplest ALU conceivable is one that only operates on two 1-bit inputs and can perform only two operations: **AND** and **OR**     ```py     def basic_alu(a, b, op):         if op == \"0\":             return (a and b)         else:             return (a or b)     ``` -   Let's implement this in Logisim!    ### Exercise: Enhance the Basic ALU 1. make it work on 4-bit values 2. add operations for XOR and NOT  - you will need a bigger multiplexor  - NOT only works on **A** - ignore **B** 3. Can you include your 4-bit adder?     # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 1  ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-10-03-constructing-adder-and-alu/",
        "teaser": null
      },{
        "title": "Subtraction Sequential Logic",
        "excerpt":"# Subtraction, Sequential Logic  ---  CS 130 // 2024-10-08    ## Schedule Heads up  * Assignment 5 due tonight * Fall break next Tuesday * Assignment 6 due next Thursday * Exam 2: October 22nd     # Review: Adder and ALU Start     ## 4-Bit Adder and a Start to an ALU     ![4 Bit Adder](../../assets/images/adder4bits.png)      ![4 Bit Adder](../../assets/images/alustart.png)        # Subtraction    ## Subtraction  - You can use the same adder circuitry to support subtraction - convert **B** into it's negative value  - flip all the bits (NOT gate)  - add 1 (give a 1 to **Cin**)   [Adder/Subtractor test vector](../../assets/addersubtractor4bit_test_vector.txt)    ## Supporting `slt`  You can even use your adder for *set on less than*  - set the adder to do subtraction   - look at the highest bit of the result  + if it is 1, then the subtraction result was negative, so set result to 1  + if it is 0, then the subtraction result was not negative, so set result to 0    ## Exercise  - Work on getting subtraction and `slt` working in your 4-bit ALU    ## Assignment  - [Assignment 6](../../assignments/assignment-6)   - make a 32-bit ALU   - `add`, `sub`, `and`, `or`, `not`, `xor`, `slt`, and anything else you want   - you can use Logisim's built-in components   - try not to duplicate circuitry for `add`, `sub`, and `slt`.   - submit screenshots of circuits *and* test vector (with comments)    # Sequential Logic     ## Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## S-R Latch     - A \"set reset\" latch is implemented with      - Let's fill in the truth table together              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 01      0 0 10      1 0 01      1 0 10      0 1 01      0 1 10           ## D Latch     - A \"data\" latch is implemented with      - Let's fill in the truth table together               $C$$D$$Q_\\text{next}$      0 0       0 1       1 0       1 1            ## Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-writing.png) ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-10-08-subtraction-sequential-logic/",
        "teaser": null
      },{
        "title": "Sequential Logic",
        "excerpt":"# Sequential Logic  ---  CS 130 // 2024-10-10    # Sequential Logic     ## Review: Combinational VS Sequential  - A **combinational circuit** is:     + Relies solely on the input to resolve its output     + Stateless / memoryless / doesn't depend on previous states  ---  - A **sequential circuit** is:     + Relies on input *and* current state to resolve its output     + Has memory       ## Review: S-R Latch     - A \"set reset\" latch is implemented with      - S = 1 $\\rightarrow$ change Q to 1 - R = 1 $\\rightarrow$ change Q to 0 - S = R = 0 $\\rightarrow$ leave Q as is              $S$$R$$Q$$\\overline{Q}$$Q_\\text{next}$$\\overline{Q}_\\text{next}$      0 0 0101      0 0 1010      1 0 0110      1 0 1010      0 1 0101      0 1 1001           ## D Latch     - A \"data\" latch is implemented with      - Let's fill in the truth table together               $C$$D$$Q_\\text{next}$      0 0       0 1       1 0       1 1            ## Clocks  - Latches are controlled by clocks that regularly trigger     ![D latch](../../assets/images/COD/d-latch.png)     ![D latch clocking diagram](../../assets/images/COD/latch_clock_diagram.png)       ## Exercise  - Experiment with these in Logisim - How can you get it to store a 1 in the latch? - How can you get it to store a 0 in the latch?     ![latch with clock](../../assets/images/latch_with_clock.png)     ![write-controlled latch](../../assets/images/write_controlled_latch.png)       ## D Flip Flop    - A (falling edge-triggered) **D flip flop** can be implemented with two D latches in series  - This configuration creates a **delay** so that the output is only changed on the **falling edge** of the clock    - a rising edge-triggered flip flop can be constructed similarly      ## Registers - A **register** is a multi-bit memory component - Registers are commonly implemented with an array of D flip flops    ## Register Files - A **register file** consists of an array of registers that can be read and written to  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file.png)    ## Register Files - **Reading** is implemented with multiplexers  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-reading.png)    ## Register Files - **Writing** is implemented with a decoder  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-writing.png)    ## Exercise: Build a register File in Logisim     - 32 bits - at least 4 registers   ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file.png)      ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-writing.png)  ![Register File Diagram](/Fall2024/CS130/assets/images/COD/register-file-reading.png)   ![register file glimpse](../../assets/images/register_file_glimpse.png)      ","categories": [],
        "tags": [],
        "url": "/Fall2024/CS130/slides/2024-10-10-sequential-logic/",
        "teaser": null
      }]
